# Data import {#sec-data-import}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("polishing")
```

## Introduction

Working with data provided by R packages is a great way to learn the tools of data science, but at some point you want to stop learning and start working with your own data.
In this chapter, you'll learn how to read plain-text rectangular files into R.

### Prerequisites

In this chapter, you'll learn how to load flat files in R with the **readr** package, which is part of the core tidyverse.

```{r}
#| label: setup
#| message: false

library(tidyverse)
```

## Reading data from a file

To begin we'll focus on the most rectangular data file type: the CSV, short for comma separate values.
Here is what a simple CSV file looks like.
The first row, commonly called the header row, gives the column names, and the following six rows give the data.

```{r}
#| echo: false
#| message: false

read_lines("data/students.csv") |> cat(sep = "\n")
```

@tbl-students-table shows a representation of the same data as a table.

```{r}
#| label: tbl-students-table
#| echo: false
#| message: false
#| tbl-cap: Data from the students.csv file as a table.

read_csv("data/students.csv") |>
  knitr::kable()
```

We can read this file into R using `read_csv()`.
The first argument is the most important: it's the path to the file.

```{r}
#| message: true

students <- read_csv("data/students.csv")
```

When you run `read_csv()` it prints out a message telling you the number of rows and columns of data, the delimiter that was used, and the column specifications (names of columns organized by the type of data the column contains).
It also prints out some information about how to retrieve the full column specification as well as how to quiet this message.
This message is an important part of readr and we'll come back to in @sec-col-types.

### Practical advice

Once you read data in, the first step usually involves transforming it in some way to make it easier to work with in the rest of your analysis.
Let's take another look at the `students` data with that in mind.

In the `favourite.food` column, there are a bunch of food items and then the character string `N/A`, which should have been an real `NA` that R will recognize as "not available".
This is something we can address using the `na` argument.

```{r}
#| message: false
students <- read_csv("data/students.csv", na = c("N/A", ""))

students
```

You might also notice that the `Student ID` and `Full Name` columns are surrounded by back ticks.
That's because they contain spaces, breaking R's usual rules for variable names.
To refer to them, you need to use those back ticks:

```{r}
students |> 
  rename(
    student_id = `Student ID`,
    full_name = `Full Name`
  )
```

An alternative approach is to use `janitor::clean_names()` to use some heuristics to turn them all into snake case at once[^data-import-1].

[^data-import-1]: The [janitor](http://sfirke.github.io/janitor/) package is not part of the tidyverse, but it offers handy functions for data cleaning and works well within data pipelines that uses `|>`.

```{r}
#| message: false

students |> janitor::clean_names()
```

Another common task after reading in data is to consider variable types.
For example, `meal_type` is a categorical variable with a known set of possible values, which in R should be represent as factor:

```{r}
students |>
  janitor::clean_names() |>
  mutate(
    meal_plan = factor(meal_plan)
  )
```

Note that the values in the `meal_type` variable has stayed exactly the same, but the type of variable denoted underneath the variable name has changed from character (`<chr>`) to factor (`<fct>`).
You'll learn more about factors in @sec-factors.

Before you move on to analyzing these data, you'll probably want to fix the `age` column as well: currently it's a character variable because of the one observation that is typed out as `five` instead of a numeric `5`.
We discuss the details of fixing this issue in @sec-import-spreadsheets.

```{r}
students <- students |>
  janitor::clean_names() |>
  mutate(
    meal_plan = factor(meal_plan),
    age = parse_number(if_else(age == "five", "5", age))
  )

students
```

### Other arguments

There are a couple of other important arguments that we need to mention, and they'll be easier to demonstrate if we first show you a handy trick.
`read_csv()` can read csv files that you create inline:

```{r}
#| message: false

read_csv(
  "a,b,c
  1,2,3
  4,5,6"
)
```

Usually `read_csv()` uses the first line of the data for the column names, which is a very common convention.
But sometime there are a few lines of metadata at the top of the file.
You can use `skip = n` to skip the first `n` lines; or use `comment = "#"` to drop all lines that start with (e.g.) `#`.

```{r}
#| message: false

read_csv(
  "The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3",
  skip = 2
)

read_csv(
  "# A comment I want to skip
  x,y,z
  1,2,3",
  comment = "#"
)
```

In other cases, the data might not have column names.
You can use `col_names = FALSE` to tell `read_csv()` not to treat the first row as headings, and instead label them sequentially from `X1` to `Xn`:

```{r}
#| message: false

read_csv(
  "1,2,3
  4,5,6",
  col_names = FALSE
)
```

Alternatively you can pass `col_names` a character vector which will be used as the column names:

```{r}
#| message: false

read_csv(
  "1,2,3
  4,5,6",
  col_names = c("x", "y", "z")
)
```

These arguments are all you need to know to read \~80% of CSV files that you'll encounter in practice.

### Other file types

Once you've mastered `read_csv()`, using readr's other functions is straightforward; it's just a matter of knowing which function to reach for:

-   `read_csv2()` reads semicolon separated files.
    These use `;` instead of `,` to separate fields, and are common in countries that use `,` as the decimal marker.

-   `read_tsv()` reads tab delimited files.

-   `read_delim()` reads in files with any delimiter, attempting to automatically guess it if you don't specify it.

-   `read_fwf()` reads fixed width files.
    You can specify fields either by their widths with `fwf_widths()` or their position with `fwf_positions()`.

-   `read_table()` reads a common variation of fixed width files where columns are separated by white space.

-   `read_log()` reads Apache style log files.

### Exercises

1.  What function would you use to read a file where fields were separated with "\|"?

2.  Apart from `file`, `skip`, and `comment`, what other arguments do `read_csv()` and `read_tsv()` have in common?

3.  What are the most important arguments to `read_fwf()`?

4.  Sometimes strings in a CSV file contain commas.
    To prevent them from causing problems they need to be surrounded by a quoting character, like `"` or `'`. By default, `read_csv()` assumes that the quoting character will be `"`.
    What argument to `read_csv()` do you need to specify to read the following text into a data frame?

    ```{r}
    #| eval: false

    "x,y\n1,'a,b'"
    ```

5.  Identify what is wrong with each of the following inline CSV files.
    What happens when you run the code?

    ```{r}
    #| eval: false

    read_csv("a,b\n1,2,3\n4,5,6")
    read_csv("a,b,c\n1,2\n1,2,3,4")
    read_csv("a,b\n\"1")
    read_csv("a,b\n1,2\na,b")
    read_csv("a;b\n1;3")
    ```

6.  Practice referring to non-syntactic names in the following data frame by:

    a.  Extracting the variable called `1`.
    b.  Plotting a scatterplot of `1` vs `2`.
    c.  Creating a new column called `3` which is `2` divided by `1`.
    d.  Renaming the columns to `one`, `two` and `three`.

    ```{r}
    annoying <- tibble(
      `1` = 1:10,
      `2` = `1` * 2 + rnorm(length(`1`))
    )
    ```

## Controlling column types {#sec-col-types}

A csv file doesn't contain any information about the type of each variable, so readr either has to guess what they are or you have to tell it.
This section will teach you how that guessing process works, how to resolve some common problems that cause it to fail, and how to supply your own column types.
Finally, we'll mention a couple of general strategies that are a useful if readr is failing catastrophically and you need to get more insight in to the structure of your file.

### Guessing types

readr uses a heuristic to figure out the column types.
For each column, it pulls the values of 1,000[^data-import-2] rows spaced evenly from the first row to the last.
It then works through the following questions:

[^data-import-2]: You can override the default of 1000 with the `guess_max` argument.

-   Does it contain only `F`, `T`, `FALSE`, or `TRUE` (ignoring case)? Then it's a logical.
-   Does it contain only numbers (e.g. `1`, `-4.5`, `5e6`, `Inf`)? Then it's a number.
-   Does it match match the ISO8601 standard? Then it's a date or date-time. (We'll come back to date/times in more detail in @sec-creating-datetimes).
-   Otherwise, it's a string.

You can see that behavior in action in this simple example:

```{r}
read_csv("
  logical,numeric,date,string
  TRUE,1,2021-01-15,abc
  false,4.5,2021-02-15,def
  T,Inf,2021-02-16,ghi"
)
```

This heuristic works well if you have a clean dataset, but in real life you'll encounter a selection of weird and wonderful failures.

### Non-standard missing values

The most common way column detection fails is that a column contains unexpected values and you get a character column instead of what you expect.
The most common cause for this is using something other than `NA` to record missing values, so you first step should always be to try setting the `na` argument.

How can you figure out what to set it to?
Well, one way is to tell readr what you expect the column types to be, and then look at the problems it reports.

```{r}
sample_data <- "
  x
  10
  .
  20
  30"

df <- read_csv(sample_data)
```

You can do that with the `col_types` argument which takes a named list:

```{r}
df <- read_csv(sample_data, col_types = cols(x = col_double()))
```

Now `read_csv()` reports that there was a problem, and that we can find out more about it with `problems()`:

```{r}
problems(df)
```

This tells us that there was a problem in row 3, col 1 where readr expected a double but got a `.`.
That suggests this dataset uses `.` for missing values:

```{r}
df <- read_csv(sample_data, na = ".")
```

### Column types

There are :

-   `col_logical()`, `col_integer()`, `col_double()`, `col_character()` which read logical, integers, doubles, and strings respectively.
-   `col_factor()` creates factors, which you'll learn more about in @sec-factors.
-   `col_date()` and `col_datetime()` create dates and date-times which you'll learn about @sec-date-and-times.
-   `col_number()` reads flexibly formatted numbers. It ignores all leading and trailing non-numbers, and ignores the "grouping mark" specified by the locale.
-   `col_skip()` skips a column so it's not included in the result.

`col_number()` is particularly useful when working with currencies, because readr can't automatically identify them:

```{r}
#| message: false

csv <- '
money
"$100.23"
"$1,456,500"
'
read_csv(csv)

read_csv(csv, col_types = cols(money = col_number()))
```

You can also use `cols()` to set the default column type.
It's usually set to `col_guess()` which automatically guesses the type as described above, but you might want to set `col_guess(.default = col_skip())` if you only want to read in the columns you specify.

There are three common reasons you might want to avoid type guessing, and tell readr the types directly:

-   You might have a column that looks like a number, but it's actually a unique identifier that should be treated like a character.
-   The column type is something that isn't guessed automatically, like a `col_number()` or `col_factor()` or non-ISO8601 dates.
-   If you're reading from a data source that changes over time, you might to explicit specify the column types to ensure that any

### String encodings

When working with non-English text another common challenge is file encodings.
To understand what's going on, we need to dive into the details of how computers represent strings.
In R, we can get at the underlying representation of a string using `charToRaw()`:

```{r}
charToRaw("Hadley")
```

Each hexadecimal number represents a byte of information: `48` is H, `61` is a, and so on.
The mapping from hexadecimal number to character is called the encoding, and in this case the encoding is called ASCII.
ASCII does a great job of representing English characters, because it's the **American** Standard Code for Information Interchange.

Things aren't so easy for languages other than English.
In the early days of computing there were many competing standards for encoding non-English characters.
For example, there were two different encodings for Europe: Latin1 (aka ISO-8859-1) was used for Western European languages and Latin2 (aka ISO-8859-2) was used for Central European languages.
In Latin1, the byte `b1` is "±", but in Latin2, it's "ą"!
Fortunately, today there is one standard that is supported almost everywhere: UTF-8.
UTF-8 can encode just about every character used by humans today, as well as many extra symbols like emoji.

readr uses UTF-8 everywhere.
This is a good default, but will fail for data produced by older systems that don't know use UTF-8.
If this happens to you, your strings will look weird when you print them.
Sometimes just one or two characters might be messed up; other times you'll get complete gibberish.
For example:

```{r}
#| message: false
x1 <- "text\nEl Ni\xf1o was particularly bad this year"
read_csv(x1)

x2 <- "text\n\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"
read_csv(x2)
```

To fix the problem you need to specify the encoding via the `locale` argument:

```{r}
#| message: false
read_csv(x1, locale = locale(encoding = "Latin1"))

read_csv(x2, locale = locale(encoding = "Shift-JIS"))
```

How do you find the correct encoding?
If you're lucky, it'll be included somewhere in the data documentation.
Unfortunately, that's rarely the case, so readr provides `guess_encoding()` to help you figure it out.
It's not foolproof, and it works better when you have lots of text (unlike here), but it's a reasonable place to start.
Expect to try a few different encodings before you find the right one.

```{r}
guess_encoding(x1)
guess_encoding(x2)
```

Encodings are a rich and complex topic, and we've only scratched the surface here.
If you'd like to learn more we recommend reading the detailed explanation at <http://kunststube.net/encoding/>.

### More problems?

Particularly the `quote`, `escape_backslash`, `escape_double`, `comment`,

Sometimes it's easier to diagnose problems if you just read in all the columns as character vectors:

```{r}
#| eval: false

df <- read_csv(
  "challenge.csv",
  col_types = cols(.default = col_character())
)
```

If you're having major parsing problems, sometimes it's easier to just read into a character vector of lines with `read_lines()`:

```{r}
#| eval: false

df <- read_lines("challenge.csv")
```

Then you can use dplyr and the tools you'll learn in @sec-strings to figure out what's going wrong.

## Reading data from multiple files {#sec-readr-directory}

Sometimes your data is split across multiple files instead of being contained in a single file.
For example, you might have sales data for multiple months, with each month's data in a separate file: `01-sales.csv` for January, `02-sales.csv` for February, and `03-sales.csv` for March.
With `read_csv()` you can read these data in at once and stack them on top of each other in a single data frame.

```{r}
sales_files <- c("data/01-sales.csv", "data/02-sales.csv", "data/03-sales.csv")
read_csv(sales_files, id = "file")
```

With the additional `id` parameter we have added a new column called `file` to the resulting data frame that identifies the file the data come from.
This is especially helpful in circumstances where the files you're reading in do not have an identifying column that can help you trace the observations back to their original sources.

If you have many files you want to read in, it can get cumbersome to write out their names as a list.
Instead, you can use the base `dir()` function to find the files for you by matching a regular expression pattern in the file names.
You'll learn more about these patterns in @sec-regular-expressions.

```{r}
sales_files <- dir("data", pattern = "sales\\.csv$", full.names = TRUE)
sales_files
```

## Writing to a file {#sec-writing-to-a-file}

readr also comes with two useful functions for writing data back to disk: `write_csv()` and `write_tsv()`.
Both functions increase the chances of the output file being read back in correctly by using the standard UTF-8 encoding for strings and ISO8601 format for date-times.

The most important arguments are `x` (the data frame to save), and `file` (the location to save it).
You can also specify how missing values are written with `na`, and if you want to `append` to an existing file.

```{r}
#| eval: false

write_csv(students, "students.csv")
```

Now let's read that csv file back in.
Note that the type information is lost when you save to csv:

```{r}
#| warning: false
#| message: false

students
write_csv(students, "students-2.csv")
read_csv("students-2.csv")
```

This makes CSVs a little unreliable for caching interim results---you need to recreate the column specification every time you load in.
There are two main options:

1.  `write_rds()` and `read_rds()` are uniform wrappers around the base functions `readRDS()` and `saveRDS()`.
    These store data in R's custom binary format called RDS:

    ```{r}
    write_rds(students, "students.rds")
    read_rds("students.rds")
    ```

2.  The arrow package allows you to read and write parquet files, a fast binary file format that can be shared across programming languages:

    ```{r}
    #| eval: false

    library(arrow)
    write_parquet(students, "students.parquet")
    read_parquet("students.parquet")
    #> # A tibble: 6 × 5
    #>   student_id full_name        favourite_food     meal_plan             age
    #>        <dbl> <chr>            <chr>              <fct>               <dbl>
    #> 1          1 Sunil Huffmann   Strawberry yoghurt Lunch only              4
    #> 2          2 Barclay Lynn     French fries       Lunch only              5
    #> 3          3 Jayendra Lyne    NA                 Breakfast and lunch     7
    #> 4          4 Leon Rossini     Anchovies          Lunch only             NA
    #> 5          5 Chidiegwu Dunkel Pizza              Breakfast and lunch     5
    #> 6          6 Güvenç Attila    Ice cream          Lunch only              6
    ```

Parquet tends to be much faster than RDS and is usable outside of R, but does require you install the arrow package.

```{r}
#| include: false
file.remove("students-2.csv")
file.remove("students.rds")
```

## Data entry

Sometimes you'll need to assemble a tibble "by hand" doing a little data entry in your R script.
There are two useful functions to help you do this which differ in whether you layout the tibble by columns or by rows.
`tibble()` works by column:

```{r}
tibble(
  x = c(1, 2, 5), 
  y = c("h", "m", "g"),
  z = c(0.08, 0.83, 0.60)
)
```

Note that every column in tibble must be same size, so you'll get an error if they're not:

```{r}
#| error: true

tibble(
  x = c(1, 2),
  y = c("h", "m", "g"),
  z = c(0.08, 0.83, 0.6)
)
```

Laying out the data by column can make it hard to see how the rows are related, so an alternative is `tribble()`, short for **tr**ansposed t**ibble**, which lets you lay out your data row by row.
`tribble()` is customized for data entry in code: column headings start with `~` and entries are separated by commas.
This makes it possible to lay out small amounts of data in an easy to read form:

```{r}
tribble(
  ~x, ~y, ~z,
  "h", 1, 0.08,
  "m", 2, 0.83,
  "g", 5, 0.60,
)
```

We'll use `tibble()` and `tribble()` later in the book to construct small examples to demonstrate how various functions work.

## Summary

In this chapter, you've learned how to load CSV files with `read_csv()` and to do your own data entry with `tibble()` and `tribble()`.
You've learned how csv files work, some of the problems you might encounter, and how to overcome them.
We'll come to data import a few times in this book: @sec-import-databases will show you how to load data from databases, @sec-import-spreadsheets from Excel and googlesheets, @sec-rectangling from JSON, and @sec-scraping from websites.

Now that you're writing a substantial amount of R code, it's time to learn more about organizing your code into files and directories.
In the next chapter, you'll learn all about the advantages of scripts and projects, and some of the many tools that they provide to make your life easier.
