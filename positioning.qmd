# Positioning {#sec-positioning}

```{r}
#| results: "asis"
#| echo: false
source("_common.R")
status("drafting")
```

## Introduction

<!--# TO DO: Add intro. -->

### Prerequisites

This chapter focuses on ggplot2, one of the core packages in the tidyverse.
To access the datasets, help pages, and functions used in this chapter, load the tidyverse by running this code:

```{r}
#| label: setup

library(tidyverse)
```

## Facets

One way to add additional variables to a plot is by mapping them to an aesthetic.
Another way, which is particularly useful for categorical variables, is to split your plot into **facets**, subplots that each display one subset of the data.

To facet your plot by a single variable, use `facet_wrap()`.
The first argument of `facet_wrap()` is a formula[^positioning-1], which you create with `~` followed by a variable name.
The variable that you pass to `facet_wrap()` should be discrete.

[^positioning-1]: Here "formula" is the name of the type of thing created by `~`, not a synonym for "equation".

```{r}
#| fig-alt: >
#|   Scatterplot of highway fuel efficiency versus engine size of cars, 
#|   faceted by class, with facets spanning two rows.

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~cyl)
```

To facet your plot with the combination of two variables, switch from `facet_wrap()` to `facet_grid()`.
The first argument of `facet_grid()` is also a formula, but now it's a double sided formula: `rows ~ cols`.

```{r}
#| fig-alt: >
#|   Scatterplot of highway fuel efficiency versus engine size of cars, faceted 
#|   by number of cylinders across rows and by type of drive train across 
#|   columns. This results in a 4x3 grid of 12 facets. Some of these facets have 
#|   no observations: 5 cylinders and 4 wheel drive, 4 or 5 cylinders and front 
#|   wheel drive.

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```

### Exercises

1.  What happens if you facet on a continuous variable?

2.  What do the empty cells in plot with `facet_grid(drv ~ cyl)` mean?
    How do they relate to this plot?

    ```{r}
    #| fig-alt: >
    #|   Scatterplot of number of cycles versus type of drive train of cars. 
    #|   The plot shows that there are no cars with 5 cylinders that are 4 
    #|   wheel drive or with 4 or 5 cylinders that are front wheel drive.

    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = drv, y = cyl))
    ```

3.  What plots does the following code make?
    What does `.` do?

    ```{r}
    #| eval: false

    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) +
      facet_grid(drv ~ .)

    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) +
      facet_grid(. ~ cyl)
    ```

4.  Take the first faceted plot in this section:

    ```{r}
    #| eval: false

    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) + 
      facet_wrap(~ class, nrow = 2)
    ```

    What are the advantages to using faceting instead of the color aesthetic?
    What are the disadvantages?
    How might the balance change if you had a larger dataset?

5.  Read `?facet_wrap`.
    What does `nrow` do?
    What does `ncol` do?
    What other options control the layout of the individual panels?
    Why doesn't `facet_grid()` have `nrow` and `ncol` arguments?

6.  Which of the following two plots makes it easier to compare engine size (`displ`) across cars with different drive trains?
    What does this say about when to place a faceting variable across rows or columns?

    ```{r}
    #| fig-alt: >
    #|   Two faceted plots, both visualizing highway fuel efficiency versus 
    #|   engine size of cars, faceted by drive train. In the top plot, facet 
    #|   are organized across rows and in the second, across columns.

    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) + 
      facet_grid(drv ~ .)

    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) + 
      facet_grid(. ~ drv)
    ```

7.  Recreate this plot using `facet_wrap()` instead of `facet_grid()`.
    How do the positions of the facet labels change?

    ```{r}
    #| fig-alt: >
    #|   Scatterplot of highway fuel efficiency versus engine size of cars, 
    #|   faceted by type of drive train across rows.

    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) +
      facet_grid(drv ~ .)
    ```

## Position adjustments

There's one more piece of magic associated with bar charts.
You can color a bar chart using either the `color` aesthetic, or, more usefully, `fill`:

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-height: 2
#| fig-alt: >
#|   Two bar charts of cut of diamonds. In the first plot, the bars have colored 
#|   borders. In the second plot, they're filled with colors. Heights of the 
#|   bars correspond to the number of diamonds in each cut category.

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, color = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

Note what happens if you map the fill aesthetic to another variable, like `clarity`: the bars are automatically stacked.
Each colored rectangle represents a combination of `cut` and `clarity`.

```{r}
#| fig-alt: >
#|   Segmented bar chart of cut of diamonds, where each bar is filled with 
#|   colors for the levels of clarity. Heights of the bars correspond to the 
#|   number of diamonds in each cut category, and heights of the colored 
#|   segments are proportional to the number of diamonds with a given clarity 
#|   level within a given cut level.

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

The stacking is performed automatically using the **position adjustment** specified by the `position` argument.
If you don't want a stacked bar chart, you can use one of three other options: `"identity"`, `"dodge"` or `"fill"`.

-   `position = "identity"` will place each object exactly where it falls in the context of the graph.
    This is not very useful for bars, because it overlaps them.
    To see that overlapping we either need to make the bars slightly transparent by setting `alpha` to a small value, or completely transparent by setting `fill = NA`.

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-height: 2
    #| fig-alt: >
    #|   Two segmented bar charts of cut of diamonds, where each bar is filled 
    #|   with colors for the levels of clarity. Heights of the bars correspond 
    #|   to the number of diamonds in each cut category, and heights of the 
    #|   colored segments are proportional to the number of diamonds with a 
    #|   given clarity level within a given cut level. However the segments 
    #|   overlap. In the first plot the segments are filled with transparent 
    #|   colors, in the second plot the segments are only outlined with colors.

    ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
      geom_bar(alpha = 1/5, position = "identity")
    ggplot(data = diamonds, mapping = aes(x = cut, color = clarity)) + 
      geom_bar(fill = NA, position = "identity")
    ```

    The identity position adjustment is more useful for 2d geoms, like points, where it is the default.

-   `position = "fill"` works like stacking, but makes each set of stacked bars the same height.
    This makes it easier to compare proportions across groups.

    ```{r}
    #| fig-alt: >
    #|   Segmented bar chart of cut of diamonds, where each bar is filled with 
    #|   colors for the levels of clarity. Height of each bar is 1 and heights 
    #|   of the colored segments are proportional to the proportion of diamonds 
    #|   with a given clarity level within a given cut level.

    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
    ```

-   `position = "dodge"` places overlapping objects directly *beside* one another.
    This makes it easier to compare individual values.

    ```{r}
    #| fig-alt: >
    #|   Dodged bar chart of cut of diamonds. Dodged bars are grouped by levels 
    #|   of cut (fair, good, very good, premium, and ideal). In each group there 
    #|   are eight bars, one for each level of clarity, and filled with a 
    #|   different color for each level. Heights of these bars represent the 
    #|   number of diamonds with a given level of cut and clarity.

    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
    ```

There's one other type of adjustment that's not useful for bar charts, but can be very useful for scatterplots.
Recall our first scatterplot.
Did you notice that the plot displays only 126 points, even though there are 234 observations in the dataset?

```{r}
#| echo: false
#| fig-alt: >
#|   Scatterplot of highway fuel efficiency versus engine size of cars that 
#|   shows a negative association.

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

The underlying values of `hwy` and `displ` are rounded so the points appear on a grid and many points overlap each other.
This problem is known as **overplotting**.
This arrangement makes it difficult to see the distribution of the data.
Are the data points spread equally throughout the graph, or is there one special combination of `hwy` and `displ` that contains 109 values?

You can avoid this gridding by setting the position adjustment to "jitter".
`position = "jitter"` adds a small amount of random noise to each point.
This spreads the points out because no two points are likely to receive the same amount of random noise.

```{r}
#| fig-alt: >
#|   Jittered scatterplot of highway fuel efficiency versus engine size of cars. 
#|   The plot shows a negative association.

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph *more* revealing at large scales.
Because this is such a useful operation, ggplot2 comes with a shorthand for `geom_point(position = "jitter")`: `geom_jitter()`.

To learn more about a position adjustment, look up the help page associated with each adjustment: `?position_dodge`, `?position_fill`, `?position_identity`, `?position_jitter`, and `?position_stack`.

### Exercises

1.  What is the problem with this plot?
    How could you improve it?

    ```{r}
    #| fig-alt: >
    #|   Scatterplot of highway fuel efficiency versus city fuel efficiency 
    #|   of cars that shows a positive association. The number of points 
    #|   visible in this plot is less than the number of points in the dataset.

    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
      geom_point()
    ```

2.  What parameters to `geom_jitter()` control the amount of jittering?

3.  Compare and contrast `geom_jitter()` with `geom_count()`.

4.  What's the default position adjustment for `geom_boxplot()`?
    Create a visualization of the `mpg` dataset that demonstrates it.

## Coordinate systems

Coordinate systems are probably the most complicated part of ggplot2.
The default coordinate system is the Cartesian coordinate system where the x and y positions act independently to determine the location of each point.
There are three other coordinate systems that are occasionally helpful.

-   `coord_flip()` switches the x and y axes.
    This is useful (for example), if you want horizontal boxplots.
    It's also useful for long labels: it's hard to get them to fit without overlapping on the x-axis.

    ```{r}
    #| fig-width: 4
    #| fig-height: 2
    #| layout-ncol: 2
    #| fig-alt: >
    #|   Two side-by-side box plots of highway fuel efficiency of cars. A 
    #|   separate box plot is created for cars in each level of class (2seater, 
    #|   compact, midsize, minivan, pickup, subcompact, and suv). In the first 
    #|   plot class is on the x-axis, in the second plot class is on the y-axis. 
    #|   The second plot makes it easier to read the names of the levels of class 
    #|   since they are listed down the y-axis, avoiding overlap.

    ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
      geom_boxplot()
    ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
      geom_boxplot() +
      coord_flip()
    ```

    However, note that you can achieve the same result by flipping the aesthetic mappings of the two variables.

    ```{r}
    #| fig-alt: >
    #|   Side-by-side box plots of highway fuel efficiency of cars. A separate 
    #|   box plot is drawn along the y-axis for cars in each level of class 
    #|   (2seater, compact, midsize, minivan, pickup, subcompact, and suv).

    ggplot(data = mpg, mapping = aes(y = class, x = hwy)) + 
      geom_boxplot()
    ```

-   `coord_quickmap()` sets the aspect ratio correctly for maps.
    This is very important if you're plotting spatial data with ggplot2.
    We don't have the space to discuss maps in this book, but you can learn more in the [Maps chapter](https://ggplot2-book.org/maps.html) of *ggplot2: Elegant graphics for data analysis*.

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-height: 2
    #| message: false
    #| fig-alt: >
    #|   Two maps of the boundaries of New Zealand. In the first plot the aspect 
    #|   ratio is incorrect, in the second plot it is correct.

    nz <- map_data("nz")

    ggplot(nz, aes(long, lat, group = group)) +
      geom_polygon(fill = "white", color = "black")

    ggplot(nz, aes(long, lat, group = group)) +
      geom_polygon(fill = "white", color = "black") +
      coord_quickmap()
    ```

-   `coord_polar()` uses polar coordinates.
    Polar coordinates reveal an interesting connection between a bar chart and a Coxcomb chart.

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-asp: 1
    #| fig-alt: >
    #|   There are two plots. On the left is a bar chart of cut of diamonds, 
    #|   on the right is a Coxcomb chart of the same data.

    bar <- ggplot(data = diamonds) + 
      geom_bar(
        mapping = aes(x = cut, fill = cut), 
        show.legend = FALSE,
        width = 1
      ) + 
      theme(aspect.ratio = 1) +
      labs(x = NULL, y = NULL)

    bar + coord_flip()
    bar + coord_polar()
    ```

### Exercises

1.  Turn a stacked bar chart into a pie chart using `coord_polar()`.

2.  What does `labs()` do?
    Read the documentation.

3.  What's the difference between `coord_quickmap()` and `coord_map()`?

4.  What does the plot below tell you about the relationship between city and highway mpg?
    Why is `coord_fixed()` important?
    What does `geom_abline()` do?

    ```{r}
    #| fig-alt: >
    #|   Scatterplot of highway fuel efficiency versus engine size of cars that 
    #|   shows a negative association. The plot also has a straight line that 
    #|   follows the trend of the relationship between the variables but does not 
    #|   go through the cloud of points, it is beneath it.

    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
      geom_point() + 
      geom_abline() +
      coord_fixed()
    ```

## The layered grammar of graphics

In the previous sections, you learned much more than just how to make scatterplots, bar charts, and boxplots.
You learned a foundation that you can use to make *any* type of plot with ggplot2.
To see this, let's add position adjustments, stats, coordinate systems, and faceting to our code template:

    ggplot(data = <DATA>) + 
      <GEOM_FUNCTION>(
         mapping = aes(<MAPPINGS>),
         stat = <STAT>, 
         position = <POSITION>
      ) +
      <COORDINATE_FUNCTION> +
      <FACET_FUNCTION>

Our new template takes seven parameters, the bracketed words that appear in the template.
In practice, you rarely need to supply all seven parameters to make a graph because ggplot2 will provide useful defaults for everything except the data, the mappings, and the geom function.

The seven parameters in the template compose the grammar of graphics, a formal system for building plots.
The grammar of graphics is based on the insight that you can uniquely describe *any* plot as a combination of a dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, and a faceting scheme.

To see how this works, consider how you could build a basic plot from scratch: you could start with a dataset and then transform it into the information that you want to display (with a stat).

```{r}
#| echo: false
#| fig-alt: >
#|   A figure demonstrating the steps for going from raw data to table of counts 
#|   where each row represents one level of cut and a count column shows how many 
#|   diamonds are in that cut level. Steps 1 and 2 are annotated. Step 1. Begin 
#|   with the diamonds dataset. Step 2. Compute counts for each cut value 
#|   with stat_count().

knitr::include_graphics("images/visualization-grammar-1.png")
```

Next, you could choose a geometric object to represent each observation in the transformed data.
You could then use the aesthetic properties of the geoms to represent variables in the data.
You would map the values of each variable to the levels of an aesthetic.

```{r}
#| echo: false
#| fig-alt: >
#|   A figure demonstrating the steps for going from raw data to table of counts 
#|   where each row represents one level of cut and a count column shows how 
#|   many diamonds are in that cut level. Each level is also mapped to a color. 
#|   Steps 3 and 4 are annotated. Step 3. Represent each observation with a bar. 
#|   Step 4. Map the fill of each bar to the ..count.. variable.

knitr::include_graphics("images/visualization-grammar-2.png")
```

You'd then select a coordinate system to place the geoms into, using the location of the objects (which is itself an aesthetic property) to display the values of the x and y variables.
At that point, you would have a complete graph, but you could further adjust the positions of the geoms within the coordinate system (a position adjustment) or split the graph into subplots (faceting).
You could also extend the plot by adding one or more additional layers, where each additional layer uses a dataset, a geom, a set of mappings, a stat, and a position adjustment.

```{r}
#| echo: false
#| fig-alt: >
#|   A figure demonstrating the steps for going from raw data to bar chart where 
#|   each bar represents one level of cut and filled in with a different color. 
#|   Steps 5 and 6 are annotated. Step 5. Place geoms in a Cartesian coordinate 
#|   system. Step 6. Map the y values to ..count.. and the x values to cut.

knitr::include_graphics("images/visualization-grammar-3.png")
```

You could use this method to build *any* plot that you imagine.
In other words, you can use the code template that you've learned in this chapter to build hundreds of thousands of unique plots.

If you'd like to learn more about the theoretical underpinnings of ggplot2, you might enjoy reading "[The Layered Grammar of Graphics](https://vita.had.co.nz/papers/layered-grammar.pdf)", the scientific paper that describes the theory of ggplot2 in detail.

## Summary

<!--# TO DO: Add summary -->
