---
title: "vectors-cevri"
author: "Nurbahar Usta"
date: "09 03 2020"
output: html_document
---

*ceviri: "Kahraman İpekdal


# Vektörler

## Giriş

Bu kitapta şimdiye kadar tibble’lara ve onlarla çalışan paketlere odaklandı. Ama kendi fonksiyonlarınızı yazmaya başladıkça ve R’de daha derinlere indikçe tibble’ların altında yatan vektörleri öğrenmeniz gerekecek. R’yi daha geleneksel bir yoldan öğrendiyseniz muhtemelen vektörlere aşinasınızdır. Çünkü R kaynaklarının çoğu konuya vektörlerden başlar ve buradan tibble’lara doğru gelir. Bana kalırsa tibble’larla başlamak daha iyidir çünkü bunlar hemen kullanılmaktadır. Bunların altındaki bileşenlere daha sonra gelinebilir.
Vektörler özellikle önemlidir çünkü yazacağınız çoğu fonksiyon vektörlerle çalışacaktır. Tibble’larla çalışan fonksiyonlar yazmak da mümkündür (ggplot2, dplyr ve tidyr gibi) ancak bu tip fonksiyonları yazmak için gereken araçlar nevi şahsına münhasırdır ve tam olarak olgunlaşmamıştır. Daha iyi bir yaklaşım üzerinde çalışıyorum (https://github.com/hadley/lazyeval) ama bu kitabın yayınlanmasına yetişmeyecek. Tamamlandığında bile yine de hala vektörleri anlamanız gerekecek; bu sadece kullanıcı dostu bir yüz yazmayı kolaylaştıracak.

### Ön koşullar

Bu bölümün odağı temel R veri yapılarıdır. Bu nedenle herhangi bir paket yüklemeniz gerekmiyor. Ancak temel R’daki birtakım tutarsızlıklardan kaçınmak için __purr__ paketinden birkaç fonksiyon kullanacağız.

```{r setup, message = FALSE}
library(tidyverse)
```

## Vektörlere giriş

İki tip vektör bulunur:

1. __Atomic__ vektörler. Bunun altı tipi vardır: 
  __logical__, __integer__, __double__,  __character__, __complex__, and 
  __raw__. Integer ve double vektörler birlikte
  __numeric__ vektörler olarak bilinir. 

2. __Lists__,  bazen başka listeleri de içerebildiklerinden bazen yinelemeli vektörler
  olarak adlandırılır.

Atomik vektörlerle listeler arasındaki temel fark atomik vektörlerin homojen, listelerin ise heterojen olmasıdır. İlgili bir obje daha vardır: `NULL`. `NULL` genellikle bir vektörün olmadığını göstermek için kullanılır (`NA` ise bir vektörde bir değerin olmadığını göstermek için kullanılır). `NULL` uzunluğu 0 olan bir vektör gibi davranır. Şekil \@ref(fig:datatypes) vektörler arasındaki ilişkileri özetlemektedir. 

```{r datatypes, echo = FALSE, out.width = "50%", fig.cap = "The hierarchy of R's vector types"}
knitr::include_graphics("diagrams/data-structures-overview.png")
```

Her vektörün iki temel özelliği vardır: 

1.  __type__, `typeof()` ile belirlenir.

    ```{r}
    typeof(letters)
    typeof(1:10)
    ```

2.  __length__,`length()` ile belirlenebilir.

    ```{r}
    x <- list("a", "b", 1:10)
    length(x)
    ```


Vectors can also contain arbitrary additional metadata in the form of attributes. Bu özellikler ek davranışlara dayanan __augmented vectors__ oluşturmak için kullanılır. Üç önemli __augmented__ vektör türü vardır:

* Faktörler tamsayı vektörlerinin üstüne inşa edilir.
* Tarihler ve tarih-zamanlar sayısal vektörlerin üstüne inşa edilir.
*	Veri çerçeveleri ve tibble’lar listelerin üzerine inşa edilir.

Bu bölümde bu önemli vektörler en basitten en karmaşığa tanıtılacaktır. Atomik vektörlerle başlayacağız; daha sonra listelere değineceğiz, çoğaltılmış vektörlerle de bitireceğiz.

## Önemli atomik vektör tipleri

En önemli atomik vektör tipleri  logical, integer, double ve character'dir.. Raw ve complex  vektörler genellikle veri analizinde kullanılır; o nedenle onları burada tartışmayacağız.

### Logical

Logical vvektörler en basit atomik vektör tipidir çünkü sadece üç değer alabilir: `FALSE`, `TRUE`, ve `NA`. Logical vektörler genelde karşılaştırma operatörleri ile yapılır. Bunlar [karşılaştırmalar] konusunda tartışılmaktadır. Bunları `c()` kullanarak el ile yapmanız da mümkündür:

```{r}
1:10 %% 3 == 0

c(TRUE, TRUE, FALSE, NA)
```

### Numeric

Integer ve double vektörler birlikte sayısal vektörler olarak bilinir. R’da sayılar double vektör olarak yerleşiktir. Bir integer yapmak için sayıdan sonra bir `L`  ekleyin: 

```{r}
typeof(1)
typeof(1L)
1.5L
```

Integer ve double arasındaki fark genellikle önemli değildir ama farkında olmanız gereken iki önemli fark bulunmaktadır:

1.  Double'lar yaklaşık değerlerdir, her zaman tam olarak sabit miktarda bellekle temsil edilemeyen kayan 
    nokta sayılarını (floating numbers) temsil eder. Bu da tüm double'ları yaklaşık değer olarak kabul etmeniz gerektiği anlamına gelir. 
    Örneğin karekök ikinin karesi nedir?
    ```{r}
    x <- sqrt(2) ^ 2
    x
    x - 2
    ```

    Bu davranış kayan nokta sayıları ile çalışırken sıklıkla karşımıza çıkar: 
    Hesaplamaların çoğu bir miktar tahmin hatası barındırır. Floating sayılarını == kullanarak 
    karşılaştırmak yerine, bir miktar sayısal hoşgörü sağlayan dplyr::near() kullanmalısınız.

2.  Integer'ların özel bir değeri vardır: `NA`. Double'larda ise dört özel değer bulunur:`NA`, `NaN`, `Inf` and `-Inf`. 
    `NaN`, `Inf` ve `-Inf` değerlerinin üçü de bölme sırasında ortaya çıkar:
   
    ```{r}
    c(-1, 0, 1) / 0
    ```

    Diğer özel değerleri kontrol etmek için `==` kullanmaktan kaçının. 
    Bunun yerine `is.finite()` ve `is.nan()` gibi yardımcı fonksiyonları kullanın.
    
    
    |                  |  0  | Inf | NA  | NaN |
    |------------------|-----|-----|-----|-----|
    | `is.finite()`    |  x  |     |     |     |
    | `is.infinite()`  |     |  x  |     |     |
    | `is.na()`        |     |     |  x  |  x  |
    | `is.nan()`       |     |     |     |  x  |


### Character

Character vektörü en karmaşık atomik vektör tipidir çünkü bir karakter vektörünün her bir elemanı bir dizgidir (string) ve bir dizgi istendiği kadar veri içerebilir.

[Dizgiler] kısmında dizgi ile nasıl çalışılacağını öğrendiniz. Burada temel dizgi uygulamasının önemli bir özelliğinden bahsetmek istiyorum: R küresel bir dizgi havuzu kullanır. Bunun anlamı şudur: Her bir özgün dizgi noktası bellekte sadece bir kez depolanır ve dizgi her kullanıldığında o gösterime işaret edilir. Bu dizgileri çoğaltmak için gereken bellek miktarını azaltır. Bu davranışı bir uygulama yaparak görebilirsiniz:

You've already learned a lot about working with strings in [strings]. Here I wanted to mention one important feature of the underlying string implementation: R uses a global string pool. This means that each unique string is only stored in memory once, and every use of the string points to that representation. This reduces the amount of memory needed by duplicated strings. You can see this behaviour in practice with `pryr::object_size()`:

```{r}
x <- "This is a reasonably long string."
pryr::object_size(x)

y <- rep(x, 1000)
pryr::object_size(y)
```

`y` doesn't take up 1,000x as much memory as `x`, because each element of `y` is just a pointer to that same string. A pointer is 8 bytes, so 1000 pointers to a 136 B string is 8 * 1000 + 136 = 8.13 kB. ---ÇEVRİLMEMİŞ

### Eksik değerler

Her atomic vektör tipinin kendi eksik değeri olduğunu unutmayın:

```{r}
NA            # logical
NA_integer_   # integer
NA_real_      # double
NA_character_ # character
```

Normalde bu farklı tipleri bilmeniz gerekmez çünkü her zaman `NA` kullanabilir ve aşağıda tartışılan örtülü zorlama kurallarını kullanarak doğru tipe çevirebilirsiniz. Bununla birlikte girdileri konusunda katı olan bazı fonksiyonlar vardır. Bu bilgiyi arka cebinizde tutmanız iyi olur; böylece gerektiğinde spesifik olabilirsiniz. 

### Alıştırmalar

1.  `is.finite(x)` ve `!is.infinite(x)` arasındaki farkı açıklayın.

2.  `dplyr::near()` ’nin kaynak kodunu okuyun (İpucu: kaynak kodu görmek için ()’i atın). 
    Bu nasıl çalışıyor?

3.  Logical bir vektör üç değer alabilir. Bir tamsayı vektörü kaç değer alabilir? 
    Bir çift kaç değer alabilir? İhtiyacınız olan araştırmayı yapmak için Google’ı kullanın.

4.  Bir double'ı integer'a dönüştürmenizi sağlayacak en az dört fonksiyon bulun. Bunların farkı nedir? Net olun.
    
5.  readr paketindeki hangi fonksiyonlar bir string'i logical, integer ve double vektöre 
    dönüştürmenizi sağlar?

## Atomic vektörleri kullanmak 

Farklı atomic vektör tiplerini öğrendiğinize göre kullanabileceğiniz önemli bazı araçlara bir göz atmak faydalı olacaktır. Bunlar şu soruların cevaplandırılmasını sağlar:

1.  Bir tipten diğerine nasıl dönüşüm yapılır ve bu ne zaman kendiliğinden olur?

2.  Bir nesnenin spesifik bir vektör tipi olduğu nasıl söylenir?

3.  Farklı uzunluklara sahip vektörlerle çalışırsanız ne olur?

4.  Bir vektörün elemanları nasıl isimlendirilir?

5.  İstenen elemanlar nasıl çekilir?

### Zorlama

Bir vektörü diğerine dönüştürmenin ya da dönüşmeye zorlamanın iki yolu vardır:

1.  Açık zorlama `as.logical()`,  `as.integer()`, `as.double()` ya da `as.character()` 
    gibi bir fonksiyon kullandığınızda olur. Açık zorlama kullandığınız her zaman, 
    düzeltmeyi "upstream" olarak yapıp yapamayacağınıza bakın; böylece daha başlangıçta 
    vektörün yanlış tipte olmasını engellemiş olursunuz. Örneğin readr `col_types` 
    özelliklerine ince ayar yapmanız gerekebilir.

2.  Örtülü zorlama bir vektörü belli bir vektör tipinin kullanılmasının öngörüldüğü 
    özel bir bağlamda kullandığınızda olur. Örneğin numeric özet fonksiyonuna sahip bir 
    logical vektör kullandığınızda ya da bir integer vektörünün kullanılmasının beklendiği 
    bir double vektör kullandığınızda...
    
Açık zorlama görece daha seyrek kullanıldığından ve örtülü zorlamanın anlaşılması kolay olduğundan burada bu ikincisine odaklanacağız.

Örtülü zorlamanın en önemli tipini görmüş durumdasınız: Mantıksal bir vektörün sayısal bir bağlamda kullanımı. Bu durumda `TRUE`, `1`’e; , `0`'a dönüştürülür. Bu da şu anlama gelir: logical bir vektörün toplamı true’ların sayısıdır ve bu vektörün ortalaması true’ların oranıdır:


```{r}
x <- sample(20, 100, replace = TRUE)
y <- x > 10
sum(y)  # how many are greater than 10?
mean(y) # what proportion are greater than 10?
```

Bazı kodlarda (özellikle eski olanlarda) örtülü zorlamanın intege'dan logical'a, zıt yönde kullanıldığını görebilirsiniz:

```{r, eval = FALSE}
if (length(x)) {
  # do something
}
```

Bu durumda `0`, `FALSE`’a ve diğer her şey `TRUE`’ya dönüştürülür. Bence bu kodunuzun anlaşılmasını zorlaştırır; bu nedenle ben bunu tavsiye etmem. Bundansa açık olmanızı öneririm: `length(x) > 0`.

`c()` kullanarak birden fazla tip içeren bir vektörü deneyip oluşturduğunuzda ne olduğunu anlamak da önemlidir: En karmaşık olan tip her zaman kazanır.

```{r}
typeof(c(TRUE, 1L))
typeof(c(1L, 1.5))
typeof(c(1.5, "a"))
```

Atomic bir vektör farklı tiplerin karışımından oluşamaz çünkü tip tam vektörün bir özelliğidir; tek tek elemanların değil. Birden çok tipi aynı vektörde karıştırmanız gerekiyorsa, bir liste kullanmalısınız. Bu konuya daha sonra kısaca değineceğiz.

### Test fonksiyonları

Bazen vektörün tipine bağlı olarak farklı şeyler yapmak istersiniz. Seçeneklerden biri `typeof()` kullanmaktır. Diğeri ise `TRUE` ya da `FALSE` veren bir test fonksiyonu kullanmaktır. Temel R `is.vector()` ve `is.atomic()` gibi pek çok fonksiyona sahiptir. Ancak bunlar sıklıkla şaşırtıcı sonuçlar verir. Bunların yerine purr tarafından sağlanan ve aşağıdaki tabloda özetlenen `is_*` fonksiyonlarını kullanmak daha güvenlidir.


|                  | lgl | int | dbl | chr | list |
|------------------|-----|-----|-----|-----|------|
| `is_logical()`   |  x  |     |     |     |      |
| `is_integer()`   |     |  x  |     |     |      |
| `is_double()`    |     |     |  x  |     |      |
| `is_numeric()`   |     |  x  |  x  |     |      |
| `is_character()` |     |     |     |  x  |      |
| `is_atomic()`    |  x  |  x  |  x  |  x  |      |
| `is_list()`      |     |     |     |     |  x   |
| `is_vector()`    |  x  |  x  |  x  |  x  |  x   |


Her bir yüklem(predicate?) `is_scalar_atomic()` gibi bir skaler versiyonu ile birlikte gelir. Bu uzunluğun 1 olduğunu kontrol eder. Örneğin fonksiyonunuzun bir argümanının tek bir mantıksal değer olduğunu kontrol etmek isterseniz bu faydalıdır.


### Scalarlar ve geri dönüşüm kuralları

R uyumlu olmak için vektör tiplerini zorlamanın yanı sıra, vektör uzunluklarını da örtülü olarak zorlar. Buna vektör geri dönüşümü denir çünkü kısa vektör, uzun vektör ile aynı uzunlukta tekrarlanır veya geri dönüştürülür.

Bu genellikle vektörleri ve scalarları karıştırırken kullanışlıdır. Scalarları tırnak içine alırım çünkü R’de aslında scalar bulunmaz. Bunun yerine tek bir sayı 1 uzunluğuna sahip bir vektördür. Scalar olmadığından yerleşik işlevlerin çoğu vektörelleştirilir, yani bir sayı vektöründe çalışırlar. Bu nedenle, örneğin şu kod çalışıyor:

```{r}
sample(10) + 100
runif(10) > 0.5
```

R’da temel matematiksel işlemler vektörlerle çalışır. Yani basit matematiksel hesaplamalar yaparken hiçbir zaman açık bir yineleme gerçekleştirmeniz gerekmez.

Aynı uzunlukta iki vektör veya bir vektör ve bir "scalar" eklerseniz ne olacağı sezgiseldir, ancak farklı uzunluklarda iki vektör eklerseniz ne olur?


```{r}
1:10 + 1:2
```

R burada en kısa olan vektörü en uzun olanla aynı uzunluğa getirecektir ki buna geri dönüşüm denir. Bu, daha uzun olanın, kısa olanın uzunluğunun tam katı olmadığı durumlar haricinde sessizdir:

```{r}
1:10 + 1:3
```

Vektör geri dönüşümü çok kısa ve zekice kodlar oluşturmak için kullanılabilir ama aynı zamanda problemlerin sessizce gizlenmesine de yol açabilir. Bu nedenle vektörelleştirilmiş fonksiyonlar düzenli olarak bir scalar dışında herhangi bir şeyi geri dönüştürdüğünüzde hata verecektir. Geri dönüştürmek istiyorsanız,`rep()` ile kendiniz yapmanız gerekir::

```{r, error = TRUE}
tibble(x = 1:4, y = 1:2)

tibble(x = 1:4, y = rep(1:2, 2))

tibble(x = 1:4, y = rep(1:2, each = 2))
```

### Vektörlerin isimlendirilmesi

Tüm vektör tipleri isimlendirilebilir. İsimlendirmeyi vektörleri `c()` ile oluştururken yapabilirsiniz:

```{r}
c(x = 1, y = 2, z = 4)
```

Ya da `purrr::set_names()` yaptıktan sonra:

```{r}
set_names(1:3, c("a", "b", "c"))
```

İsimlendirilmiş vektörler, biraz sonra tanımlanacak olan altkümeleme için çok kullanışlıdır. 


### Altkümeleme {#vector-subsetting}

Şimdiye kadar bir tibble’daki satırları `dplyr::filter()` kullanarak filtreledik. `filter()` sadece tibble ile çalışır; bu nedenle vektörler için yeni bir araca ihtiyacımız var ki o da şudur: `[`. Bu bir altkümeleme fonksiyonudur ve `x[a]`’da olduğu gibi kullanılır. Bir vektörü altkümeleyebileceğiniz dört şey vardır:

1.  Sadece integer'lardan oluşan numeric bir vektör. Integer'ların hepsi ya pozitif ya negatif ya da sıfır olmalıdır.
    
    Pozitif integer'larla altkümeleme yapmak elemanları o konumlarında tutar:
    
    ```{r}
    x <- c("one", "two", "three", "four", "five")
    x[c(3, 2, 5)]
    ```
    
    Bir konumu tekrar ederek daha uzun bir girdi ya da çıktı yapabilirsiniz:
    
    ```{r}
    x[c(1, 1, 5, 5, 5, 2)]
    ```
    
    Negatif değerler elemanları belirlenen noktalara bırakır:
    
    ```{r}
    x[c(-1, -3, -5)]
    ```
    
    Pozitif ve negatif değerleri karışık olarak kullanmak bir hatadır:
    
    ```{r, error = TRUE}
    x[c(1, -1)]
    ```

    Hata mesajı sıfır ile altkümelemeyi hatırlatmaktadır ki sonuçta bu bir değer vermez:
    
    ```{r}
    x[0]
    ```
    
    Bu genelde çok kullanışlı değildir ama fonksiyonunuzu test etmek için yaygın olmayan veri yapıları 
    oluşturmak istediğinizde yardımı dokunacaktır.
  
2.	Logical bir vektör ile altkümeleme bütün değerleri `TRUE` değerine karşılık gelen tüm değerleri tutar. 
    Bu genelde karşılaştırma fonksiyonları ile birlikte kullanıldığında yararlıdır.
    
    ```{r}
    x <- c(10, 3, NA, 5, 8, 1, NA)
    
    # x’in butun eksik olmayan degerleri
    x[!is.na(x)]
    
    # x’in butun cift (ya da eksik) degerleri
    x[x %% 2 == 0]
    ```

3.	Bir vektörü isimlendirdiyseniz bunu bir character vektörü ile altkümeleyebilirsiniz:
    
    ```{r}
    x <- c(abc = 1, def = 2, xyz = 5)
    x[c("xyz", "def")]
    ```
    
    Pozitif integer'larda olduğu gibi, bireysel girişleri çoğaltmak için character vektörünü de kullanabilirsiniz..

4.  Altkümelemenin en basit tipi hiçbirşey yapmamaktır. `x[]`, x’in tamamını verir. Bu vektörleri altkümelemede 
    kullanışlı değildir ama matrisleri (ve diğer çok boyutlu yapıları) altkümelemede işe yarar çünkü indeksi boş 
    bırakarak bütün satır ve sütunları seçmenize olanak verir. Örneğin `x` 2d ise `x[1, ]` ilk satırı ve bütün 
    sütunları seçerken, `x[, -1]` bütün satırları ve birincisi hariç bütün sütunları seçer.


Altkümeleme uygulamaları hakkında daha fazla şey öğrenmek için __Advanced_R__’ın [Subsetting] bölümünü okuyabilirsiniz: <http://adv-r.had.co.nz/Subsetting.html#applications>

`[`‘nin `[[` şeklinde önemli bir çeşidi vardır. `[[` sadece tek bir elemanı çıkarır ve her zaman isimleri atar. Tıpkı bir döngüde (loop) olduğu gibi tek bir parçayı çıkardığınızı açık bir şekilde belirtmek istediğinizde bunu kullanabilirsiniz. `[` ile `[[` arasındaki ayrım listelerde büyük önem kazanır. Bunu kısaca göreceğiz.

### Alıştırmalar

1.  What does `mean(is.na(x))` tell you about a vector `x`? What about
    `sum(!is.finite(x))`?

1.  Carefully read the documentation of `is.vector()`. What does it actually
    test for? Why does `is.atomic()` not agree with the definition of 
    atomic vectors above?
    
1.  Compare and contrast `setNames()` with `purrr::set_names()`.

1.  Create functions that take a vector as input and returns:
    
    1. The last value.  Should you use `[` or `[[`?

    1. The elements at even numbered positions.
    
    1. Every element except the last value.
    
    1. Only even numbers (and no missing values).

1.  Why is `x[-which(x > 0)]` not the same as `x[x <= 0]`? 

1.  What happens when you subset with a positive integer that's bigger
    than the length of the vector? What happens when you subset with a 
    name that doesn't exist?

## Recursive vectors (lists) {#lists}

Lists are a step up in complexity from atomic vectors, because lists can contain other lists. This makes them suitable for representing hierarchical or tree-like structures. You create a list with `list()`:

```{r}
x <- list(1, 2, 3)
x
```

A very useful tool for working with lists is `str()` because it focusses on the **str**ucture, not the contents.

```{r}
str(x)

x_named <- list(a = 1, b = 2, c = 3)
str(x_named)
```

Unlike atomic vectors, `list()` can contain a mix of objects:

```{r}
y <- list("a", 1L, 1.5, TRUE)
str(y)
```

Lists can even contain other lists!

```{r}
z <- list(list(1, 2), list(3, 4))
str(z)
```

### Visualising lists

To explain more complicated list manipulation functions, it's helpful to have a visual representation of lists. For example, take these three lists:

```{r}
x1 <- list(c(1, 2), c(3, 4))
x2 <- list(list(1, 2), list(3, 4))
x3 <- list(1, list(2, list(3)))
```

I'll draw them as follows:

```{r, echo = FALSE, out.width = "75%"}
knitr::include_graphics("diagrams/lists-structure.png")
```

There are three principles:

1.  Lists have rounded corners. Atomic vectors have square corners.
  
1.  Children are drawn inside their parent, and have a slightly darker
    background to make it easier to see  the hierarchy.
  
1.  The orientation of the children (i.e. rows or columns) isn't important, 
    so I'll pick a row or column orientation to either save space or illustrate 
    an important property in the example.

### Subsetting

There are three ways to subset a list, which I'll illustrate with a list named `a`:

```{r}
a <- list(a = 1:3, b = "a string", c = pi, d = list(-1, -5))
```

*   `[` extracts a sub-list. The result will always be a list.

    ```{r}
    str(a[1:2])
    str(a[4])
    ```
    
    Like with vectors, you can subset with a logical, integer, or character
    vector.
    
*   `[[` extracts a single component from a list. It removes a level of 
    hierarchy from the list.

    ```{r}
    str(a[[1]])
    str(a[[4]])
    ```

*   `$` is a shorthand for extracting named elements of a list. It works
    similarly to `[[` except that you don't need to use quotes.
    
    ```{r}
    a$a
    a[["a"]]
    ```

The distinction between `[` and `[[` is really important for lists, because `[[` drills down into the list while `[` returns a new, smaller list. Compare the code and output above with the visual representation in Figure \@ref(fig:lists-subsetting).

```{r lists-subsetting, echo = FALSE, out.width = "75%", fig.cap = "Subsetting a list, visually."}
knitr::include_graphics("diagrams/lists-subsetting.png")
```

### Lists of condiments

The difference between `[` and `[[` is very important, but it's easy to get confused. To help you remember, let me show you an unusual pepper shaker.

```{r, echo = FALSE, out.width = "25%"} 
knitr::include_graphics("images/pepper.jpg")
```

If this pepper shaker is your list `x`, then, `x[1]` is a pepper shaker containing a single pepper packet:

```{r, echo = FALSE, out.width = "25%"} 
knitr::include_graphics("images/pepper-1.jpg")
```

`x[2]` would look the same, but would contain the second packet. `x[1:2]` would be a pepper shaker containing two pepper packets. 

`x[[1]]` is:

```{r, echo = FALSE, out.width = "25%"} 
knitr::include_graphics("images/pepper-2.jpg")
```

If you wanted to get the content of the pepper package, you'd need `x[[1]][[1]]`:

```{r, echo = FALSE, out.width = "25%"} 
knitr::include_graphics("images/pepper-3.jpg")
```

### Exercises

1.  Draw the following lists as nested sets:

    1.  `list(a, b, list(c, d), list(e, f))`
    1.  `list(list(list(list(list(list(a))))))`

1.  What happens if you subset a tibble as if you're subsetting a list?
    What are the key differences between a list and a tibble?

## Attributes

Any vector can contain arbitrary additional metadata through its __attributes__. You can think of attributes as named list of vectors that can be attached to any object. 
You can get and set individual attribute values with `attr()` or see them all at once with `attributes()`.

```{r}
x <- 1:10
attr(x, "greeting")
attr(x, "greeting") <- "Hi!"
attr(x, "farewell") <- "Bye!"
attributes(x)
```

There are three very important attributes that are used to implement fundamental parts of R:

1. __Names__ are used to name the elements of a vector.
1. __Dimensions__ (dims, for short) make a vector behave like a matrix or array.
1. __Class__ is used to implement the S3 object oriented system.

You've seen names above, and we won't cover dimensions because we don't use matrices in this book. It remains to describe the class, which controls how __generic functions__ work. Generic functions are key to object oriented programming in R, because they make functions behave differently for different classes of input. A detailed discussion of object oriented programming is beyond the scope of this book, but you can read more about it in _Advanced R_ at <http://adv-r.had.co.nz/OO-essentials.html#s3>.

Here's what a typical generic function looks like:

```{r}
as.Date
```

The call to "UseMethod" means that this is a generic function, and it will call a specific __method__, a function, based on the class of the first argument. (All methods are functions; not all functions are methods). You can list all the methods for a generic with `methods()`:

```{r}
methods("as.Date")
```

For example, if `x` is a character vector, `as.Date()` will call `as.Date.character()`; if it's a factor, it'll call `as.Date.factor()`.

You can see the specific implementation of a method with `getS3method()`:

```{r}
getS3method("as.Date", "default")
getS3method("as.Date", "numeric")
```

The most important S3 generic is `print()`: it controls how the object is printed when you type its name at the console. Other important generics are the subsetting functions `[`, `[[`, and `$`. 

## Augmented vectors

Atomic vectors and lists are the building blocks for other important vector types like factors and dates. I call these __augmented vectors__, because they are vectors with additional __attributes__, including class. Because augmented vectors have a class, they behave differently to the atomic vector on which they are built. In this book, we make use of four important augmented vectors:

* Factors
* Dates 
* Date-times
* Tibbles

These are described below.

### Factors

Factors are designed to represent categorical data that can take a fixed set of possible values. Factors are built on top of integers, and have a levels attribute:

```{r}
x <- factor(c("ab", "cd", "ab"), levels = c("ab", "cd", "ef"))
typeof(x)
attributes(x)
```

### Dates and date-times

Dates in R are numeric vectors that represent the number of days since 1 January 1970.

```{r}
x <- as.Date("1971-01-01")
unclass(x)

typeof(x)
attributes(x)
```

Date-times are numeric vectors with class `POSIXct` that represent the number of seconds since 1 January 1970. (In case you were wondering, "POSIXct" stands for "Portable Operating System Interface", calendar time.)

```{r}
x <- lubridate::ymd_hm("1970-01-01 01:00")
unclass(x)

typeof(x)
attributes(x)
```

The `tzone` attribute is optional. It controls how the time is printed, not what absolute time it refers to.

```{r}
attr(x, "tzone") <- "US/Pacific"
x

attr(x, "tzone") <- "US/Eastern"
x
```

There is another type of date-times called POSIXlt. These are built on top of named lists:

```{r}
y <- as.POSIXlt(x)
typeof(y)
attributes(y)
```

POSIXlts are rare inside the tidyverse. They do crop up in base R, because they are needed to extract specific components of a date, like the year or month. Since lubridate provides helpers for you to do this instead, you don't need them. POSIXct's are always easier to work with, so if you find you have a POSIXlt, you should always convert it to a regular data time `lubridate::as_date_time()`.

### Tibbles

Tibbles are augmented lists: they have class "tbl_df" + "tbl" + "data.frame", and `names` (column) and `row.names` attributes:

```{r}
tb <- tibble::tibble(x = 1:5, y = 5:1)
typeof(tb)
attributes(tb)
```

The difference between a tibble and a list is that all the elements of a data frame must be vectors with the same length. All functions that work with tibbles enforce this constraint.

Traditional data.frames have a very similar structure:

```{r}
df <- data.frame(x = 1:5, y = 5:1)
typeof(df)
attributes(df)
```

The main difference is the class. The class of tibble includes "data.frame" which means tibbles inherit the regular data frame behaviour by default.

### Exercises

1.  What does `hms::hms(3600)` return? How does it print? What primitive
    type is the augmented vector built on top of? What attributes does it 
    use?
    
1.  Try and make a tibble that has columns with different lengths. What
    happens?

1.  Based on the definition above, is it ok to have a list as a
    column of a tibble?
