---
title: "visualize-ceviri"
author: "Dilsad"
---
<!-- # Data visualisation -->
# Veri görselleştirme

<!-- ## Introduction -->
## Giriş

<!-- "The simple graph has brought more information to the data analyst’s mind 
> than any other device." --- John Tukey -->

> "Basit bir grafik bir veri çözümleyicinin aklına herhangi başka bir araçtan daha fazla bilgi getirmiştir." --- John Tukey

<!-- This chapter will teach you how to visualise your data using ggplot2. R has several systems for making graphs, but ggplot2 is one of the most elegant and most versatile. ggplot2 implements the __grammar of graphics__, a coherent system for describing and building graphs. With ggplot2, you can do more faster by learning one system and applying it in many places. --> 

Bu bölüm size ggplot2 kullanarak datanızı nasıl görselleştirebileceğinizi öğretecek. R birkaç tane grafik yapma sistemine sahip, ama ggplot2 aralarındaki en şık ve çok yönlü olanı. ggplot2 __grammar of graphics__ adında grafik yapmaya ve tanımlamaya uygun bir aracı devreye sokar. ggplot2 ile bir sistemi öğrenip, birçok yere uygulayarak çok daha hızlı olabilirsiniz.

<!-- If you'd like to learn more about the theoretical underpinnings of ggplot2 before you start, I'd recommend reading "The Layered Grammar of Graphics", <http://vita.had.co.nz/papers/layered-grammar.pdf>.--> 

Eğer başlamadan önce ggplot2'nin teorik temeli hakkında daha fazla bilgilenmek isterseniz, "The Layered Grammar of Graphics" isimli dökümanı öneririm, <http://vita.had.co.nz/papers/layered-grammar.pdf> .

<!-- ### Prerequisites --> 

### Ön hazırlıklar

<!-- This chapter focusses on ggplot2, one of the core members of the tidyverse. To access the datasets, help pages, and functions that we will use in this chapter, load the tidyverse by running this code: --> 

Bu bölüm ana tidyverse paketi üyelerinden biri olan ggplot2'ye odaklanmaktadır. Bu bölümde kullanacağımız veri setlerine, yardım sayfalarına ve fonksiyonlara ulaşabilmek için öncelikle aşağıdaki kodu kullanarak tidyverse paketini yükleyin:

```{r setup}
library(tidyverse)
```

<!-- That one line of code loads the core tidyverse; packages which you will use in almost every data analysis. It also tells you which functions from the tidyverse conflict with functions in base R (or from other packages you might have loaded). --> 

Bu tek satırlık kod ana tidyverse paketini, hemen hemen her data analizinde kullanacağınız paketleri, yüklüyor. Ek olarak, size tidyverse'ün hangi fonksiyonlarının temel R fonksiyonlarıyla (ya da yüklemiş olduğunuz başka paketlerin fonksiyonlarıyla) uyuşmadığını da söylüyor.

<!-- If you run this code and get the error message "there is no package called ‘tidyverse’", you'll need to first install it, then run `library()` once again. --> 

Eğer bu kodu çalıştırdığınızda "there is no package called ‘tidyverse’" ("‘tidyverse’ adında bir paket bulunmamaktadır") şeklinde bir hata mesajı alırsanız, öncelikle tidyverse paketini kurmanız, sonra `library()` kodunu bir kere daha çalıştırmanız gerekir.

```{r eval = FALSE}
install.packages("tidyverse")
library(tidyverse)
```

<!-- You only need to install a package once, but you need to reload it every time you start a new session. --> 

Bir paketi sadece bir kere kurmanız yeterlidir, ancak her yeni bir oturum başlattığınızda 
tekrardan yüklemeniz gerekir.

<!-- If we need to be explicit about where a function (or dataset) comes from, we'll use the special form `package::function()`. For example, `ggplot2::ggplot()` tells you explicitly that we're using the `ggplot()` function from the ggplot2 package. --> 

Eğer bir fonksiyonun (ya da veri setinin) nereden geldiği konusunda daha açık olmamız gerekirse, `package::function()` (paket adı:fonksiyon adı) şekline özel bir kod kullabiliriz. Mesela, `ggplot2::ggplot()` size açıkça ggplot2 paketinden `ggplot()` fonksiyonunu kullandığımızı söyler.

<!-- ## First steps --> 

## İlk adımlar

<!-- Let's use our first graph to answer a question: Do cars with big engines use more fuel than cars with small engines? You probably already have an answer, but try to make your answer precise. What does the relationship between engine size and fuel efficiency look like? Is it positive? Negative? Linear? Nonlinear? --> 

İlk grafiğimizi bir soruyu cevaplamak için kullanalım: Büyük motorlu araçlar, küçük motorlu araçlara göre daha fazla yakıt kullanır mı? Muhtemelen buna bir cevabınız zaten var, ama cevabınızı daha doğru sunmaya çalışın. Motor büyüklüğü ve yakıt verimi arasındaki ilişki neye benzer? Doğru orantılı mıdır? Ters orantılı mıdır? Doğrusal mıdır, değil midir?

<!-- ### The `mpg` data frame --> 

### `mpg` veri çerçevesi

<!-- You can test your answer with the `mpg` __data frame__ found in ggplot2 (aka  `ggplot2::mpg`). A data frame is a rectangular collection of variables (in the columns) and observations (in the rows). `mpg` contains observations collected by the US Environmental Protection Agency on 38 models of car. --> 

ggplot2'nin içinde bulunana `mpg` __veri çerçevesi__ ile cevabınızı test edebilirsiniz (`ggplot2::mpg`). Veri çerçevesi, değişkenlerin (sütunlar) ve gözlemlerin (satırlar) dikdörtgen bir derlemesidir. `mpg`, ABD Çevre Koruma Ajansı tarafından toplanmış olan 38 araba modeline ait gözlemleri içerir.

```{r}
mpg
```

<!-- Among the variables in `mpg` are: --> 

`mpg` içindeki değişkenler:

<!-- 1. `displ`, a car's engine size, in litres. --> 

1. `displ`, bir arabanın litre biriminden motor büyüklüğü.

<!-- 2. `hwy`, a car's fuel efficiency on the highway, in miles per gallon (mpg). 
  A car with a low fuel efficiency consumes more fuel than a car with a high 
  fuel efficiency when they travel the same distance.  --> 
  
2. `hwy`, bir arabanın galon başına mil (mpg) biriminden otobandaki yakıt verimi.
Aynı mesafeyi kat ettiklerinde düşük yakıt verimli bir araba, yüksek yakıt verimli bir 
arabadan daha fazla yakıt tüketir.

<!-- To learn more about `mpg`, open its help page by running `?mpg`. --> 

`mpg` hakkında daha fazla bilgiye erişmek için, `?mpg` kodunu çalıştırarak yardım sayfasını açabilirsiniz.

<!-- ### Creating a ggplot --> 

### ggplot oluşturmak

<!-- To plot `mpg`, run this code to put `displ` on the x-axis and `hwy` on the y-axis: -->

`mpg`'yi grafiklemek için aşağıdaki kodu x-eksenine `displ`, y-eksenine `hwy` gelecek şekilde çalıştırın:

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

<!-- The plot shows a negative relationship between engine size (`displ`) and fuel efficiency (`hwy`). In other words, cars with big engines use more fuel. Does this confirm or refute your hypothesis about fuel efficiency and engine size? -->

Grafik motor büyüklüğü (`displ`) ve yakıt verimi (`hwy`) arasında ters orantılı bir ilişki gösteriyor. Başka bir deyişle, büyük motorlu araçlar daha fazla yakıt kullanıyor. Bu sonuç sizin yakıt verimi ve motor büyüklüğü hakkındaki hipotezinizle uyuşuyor mu?

<!-- With ggplot2, you begin a plot with the function `ggplot()`. `ggplot()` creates a coordinate system that you can add layers to. The first argument of `ggplot()` is the dataset to use in the graph. So `ggplot(data = mpg)` creates an empty graph, but it's not very interesting so I'm not going to show it here. -->

ggplot2 ile grafik yapmaya `ggplot()` fonksiyonuyla başladınız. `ggplot()` katmanlar ekleyebileceğiniz bir koordinat sistemi oluşturuyor.  `ggplot()` 'un ilk değişkeni grafiklemek istediğiniz veri seti. Yani, `ggplot(data = mpg)` boş bir grafik oluşturuyor, ancak bu çok ilginç olmadıgından burada göstermeyeceğim.

<!-- You complete your graph by adding one or more layers to `ggplot()`. The function `geom_point()` adds a layer of points to your plot, which creates a scatterplot. ggplot2 comes with many geom functions that each add a different type of layer to a plot. You'll learn a whole bunch of them throughout this chapter. -->

Grafiğinizi `ggplot()`'a bir ya da birden fazla katman ekleyerek tamamlıyorsunuz. `geom_point()` fonksiyonu grafiğinize nokta katmanı ekler, bu da bir dağılım grafiği oluşturur. ggplot2 geom denilen bir çok fonksiyon ile beraber gelir, her biri grafiğe başka tipte bir katman ekler. Bu bölüm boyunca bunlar hakkında bir sürü şey öğreneceksiniz.

<!-- Each geom function in ggplot2 takes a `mapping` argument. This defines how variables in your dataset are mapped to visual properties. The `mapping` argument is always paired with `aes()`, and the `x` and `y` arguments of `aes()` specify which variables to map to the x and y axes. ggplot2 looks for the mapped variables in the `data` argument, in this case, `mpg`. -->

ggplot2 içindeki her bir geom fonksiyonu için bir `mapping` değişkeni gerekmektedir. Bu veri setiniz içindeki değişkenlerin görsel özellikler ile nasıl eşleştirileceğini tanımlar. `mapping` değişkeni her zaman `aes()` ile `aes()`'in değişkenleri olan, x ve y eksenlerinin nerelerine gelmesi gerektiğini belirten `x` ve `y` argümanları ile beraberdir. ggplot2, `data` değişkeninin içinde tanımlanmış olan bu argümanları arar, bizim durumumuzda bu `mpg`'dir.

<!-- ### A graphing template -->
### Grafik şablonu

<!-- Let's turn this code into a reusable template for making graphs with ggplot2. To make a graph, replace the bracketed sections in the code below with a dataset, a geom function, or a collection of mappings. -->

Şimdi bu kodu ggplot2 ile grafik yapmak için tekrar kullanılabilen bir şablona dönüştürelim. Grafik yapmak için aşağıdaki kodda parantez içindeki yerleri bir veri seti, geom fonksiyonu veya bir eşleme (`mapping` ) derlemesi ile değiştirin.

```{r eval = FALSE}
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))
```

<!-- The rest of this chapter will show you how to complete and extend this template to make different types of graphs. We will begin with the `<MAPPINGS>` component. -->

Bu bölümün geri kalanı size farklı grafikler yapmak için bu şablonu nasıl tamamlamanız ve genişletmeniz gerektiğini anlatacak. `<MAPPINGS>` bileşeni ile başlayacağız.

<!-- ### Exercises -->

### Alıştırmalar

<!-- 1.  Run `ggplot(data = mpg)`. What do you see? -->

1. `ggplot(data = mpg)` kodunu çalıştırın. Ne görüyorsunuz?

<!-- 2.  How many rows are in `mpg`? How many columns? -->

2. `mpg`'de kaç tane satır ve sütun var?

<!-- 3.  What does the `drv` variable describe?  Read the help for `?mpg` to find
    out. -->
    
3. `drv` değişkeni neyi tanımlıyor? Öğrenmek için `?mpg` ile yardım sayfasını okuyun.
     
<!-- 4.  Make a scatterplot of `hwy` vs `cyl`. -->

4. `hwy` ve `cyl` ilişkisinin dağılım grafiğini oluşturun.

<!-- 5.  What happens if you make a scatterplot of `class` vs `drv`? Why is
    the plot not useful? -->
    
5. `class` ve `drv` ilişkisinin dağılım grafiğini oluşturunca sonuç ne oluyor? 
Bu grafik neden kullanılabilir değil?

<!-- ## Aesthetic mappings -->
## Estetik eşleme

<!-- > "The greatest value of a picture is when it forces us to notice what we
> never expected to see." --- John Tukey -->

> "Bir resmin en değerli olduğu zaman bizi hiç beklemediğimiz bir şeyi görmeye zorladığındadır." --- John Tukey

<!-- In the plot below, one group of points (highlighted in red) seems to fall outside of the linear trend. These cars have a higher mileage than you might expect. How can you explain these cars? -->

Aşağıdaki grafikte, bir grup noktanın (kırmızıyla belirtilmiştir) doğrusal eğilimin dışına düştüğü görülüyor. Bu arabalar beklediğinizden daha fazla mesafe kat etmiş. Bu arabaları nasıl açıklarsınız?

```{r, echo = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() + 
  geom_point(data = dplyr::filter(mpg, displ > 5, hwy > 20), colour = "red", size = 2.2)
```

<!-- Let's hypothesize that the cars are hybrids. One way to test this hypothesis is to look at the `class` value for each car. The `class` variable of the `mpg` dataset classifies cars into groups such as compact, midsize, and SUV. If the outlying points are hybrids, they should be classified as compact cars or, perhaps, subcompact cars (keep in mind that this data was collected before hybrid trucks and SUVs became popular). -->

Bu arabaların hibrit olduklarını düşünelim. Bu hipotezi test etmenin bir yolu, her arabanın `class` değişkenine bakmaktır. `mpg` veri setinin içindeki `class` değişkeni arabaları kompakt, orta ölçekli ve SUV şeklinde sınıflandırır. Eğer dışarıda kalan noktalar hibritse bu arabalar kompakt ya da tercihen yarı-kompakt olarak sınıflandırılır (unutmayın ki bu veri hibrit kamyonlar ve SUVler popüler olmadan önce toplanmıştır).

<!-- You can add a third variable, like `class`, to a two dimensional scatterplot by mapping it to an __aesthetic__. An aesthetic is a visual property of the objects in your plot. Aesthetics include things like the size, the shape, or the color of your points. You can display a point (like the one below) in different ways by changing the values of its aesthetic properties. Since we already use the word "value" to describe data, let's use the word "level" to describe aesthetic properties. Here we change the levels of a point's size, shape, and color to make the point small, triangular, or blue: -->

İki boyutlu dağılım grafiğine, bir __estetik__ eşleyerek, `class` gibi, üçüncü bir değişken ekleyebilirsiniz. Bir stetik, grafiğinizdeki nesnelerin bir görsel özelliğidir. Estetikler noktalarınızn boyut, biçim veya renklerini içerir. Bir noktayı, estetik özelliklerini değiştirerek (aşağıdaki gibi) çeşitli şekillerde gösterebilirsiniz. "Değer" kelimesini veriyi tanımlamak için kullandığımzdan ötürü, estetik özellikleri tanımlamak için "kademe" kelimesini kullanalım. Burada bir noktayı küçük, üçgen şeklinde veya mavi yapmak için; boyut, biçim ve renk kademelerini değiştiriyoruz:

```{r, echo = FALSE, asp = 1/4}
ggplot() +
  geom_point(aes(1, 1), size = 20) +
  geom_point(aes(2, 1), size = 10) + 
  geom_point(aes(3, 1), size = 20, shape = 17) + 
  geom_point(aes(4, 1), size = 20, colour = "blue") + 
  scale_x_continuous(NULL, limits = c(0.5, 4.5), labels = NULL) + 
  scale_y_continuous(NULL, limits = c(0.9, 1.1), labels = NULL) + 
  theme(aspect.ratio = 1/3)
```

<!-- You can convey information about your data by mapping the aesthetics in your plot to the variables in your dataset. For example, you can map the colors of your points to the `class` variable to reveal the class of each car. -->

Grafiğinizdeki estetiği veri setinizdeki değişkenlerle eşleştirerek verilerinizle ilgili bilgileri aktarabilirsiniz. Örneğin, her bir aracın sınıfını ortaya çıkarmak için noktalarınızın renklerini `class` değişkenine eşleyebilirsiniz.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

<!-- (If you prefer British English, like Hadley, you can use `colour` instead of `color`.) -->

(Eğer siz de Hadley gibi İngiliz İngilizcesi tercih ediyorsanız, `color` yerine `colour` kullanabilirsiniz.)

<!-- To map an aesthetic to a variable, associate the name of the aesthetic to the name of the variable inside `aes()`. ggplot2 will automatically assign a unique level of the aesthetic (here a unique color) to each unique value of the variable, a process known as __scaling__. ggplot2 will also add a legend that explains which levels correspond to which values. -->

Bir estetiği bir değişkene eşlemek için, `aes()` içinde estetiğin adını değişkenin adıyla ilişkilendirin. ggplot2 otomatik olarak her özgün değişken değeri için, özgün bir estetik kademesi atayacaktır (burada özgün bir renk), bu işleme __ölçeklendirme__ adı verilir. ggplot2 ayrıca her kademe-değişken eşleşmesini açılayan bir gösterge de ekleyecektir.

<!-- The colors reveal that many of the unusual points are two-seater cars. These cars don't seem like hybrids, and are, in fact, sports cars! Sports cars have large engines like SUVs and pickup trucks, but small bodies like midsize and compact cars, which improves their gas mileage. In hindsight, these cars were unlikely to be hybrids since they have large engines. -->

Renklere göre, olağandışı olan tüm noktalar iki kişilik arabalar. Bu arabalar hibrit olmamanın yanı sıra aslında spor arabalar! Spor arabalar, SUVler ve kamyonetler gibi büyük motorlara, ama orta ölçekli ve kompakt arabalar gibi küçük kasalara sahiptir; bu da onların daha fazla mesafe kat edebilmesini sağlar. Aslında bakıldığında, bu arabalar büyük motorlara sahip olduklarından dolayı hibrit olmaları pek de olası değildir.

<!-- In the above example, we mapped `class` to the color aesthetic, but we could have mapped `class` to the size aesthetic in the same way. In this case, the exact size of each point would reveal its class affiliation. We get a _warning_ here, because mapping an unordered variable (`class`) to an ordered aesthetic (`size`) is not a good idea. -->

Yukarıdaki örnekte, `class` değişkenini renk estetiğine eşledik, ama aynı şekilde `class` değişkenini boyut estetiğine de eşleyebilirdik. Bu durumda, her bir noktanın tam boyutu sınıflandırmasıyla ilişkili olurdu. Burada bir _uyarı_ alıyoruz, çünkü sıralanmamış bir değişkeni (`class`), sıralanmış bir estetiğe (`size`) eşlemek iyi bir fikir değil.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```

<!-- Or we could have mapped `class` to the _alpha_ aesthetic, which controls the transparency of the points, or to the shape aesthetic, which controls the shape of the points. -->

Ya da `class` değişkenini, noktaların saydamlığını kontrol eden _alpha_ estetiğine veya noktaların biçimini kontrol eden biçim estetiğine eşleyebilirdik.

```{r out.width = "50%", fig.align = 'default', warning = FALSE, fig.asp = 1/2, fig.cap =""}
# Left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))

# Right
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

<!-- What happened to the SUVs? ggplot2 will only use six shapes at a time. By default, additional groups will go unplotted when you use the shape aesthetic. -->

SUVlere ne oldu? ggplot2 aynı anda altı biçim kullanacaktır. Varsayımsal olarak, biçim estetiğinı kullandığınzda eklenen gruplar grafiklenmeyecektir.

<!-- For each aesthetic, you use `aes()` to associate the name of the aesthetic with a variable to display. The `aes()` function gathers together each of the aesthetic mappings used by a layer and passes them to the layer's mapping argument. The syntax highlights a useful insight about `x` and `y`: the x and y locations of a point are themselves aesthetics, visual properties that you can map to variables to display information about the data. -->

Her estetiği görselleştirebilmek için, estetiğin adıyle değişkenin adını `aes()` kullanarak ilişkilendirmeniz gerekir. `aes()` fonksiyonu her estetik eşleme katmanını bir araya toplayarak onu eşleme argümanından geçirir. Sözdizimi, `x` ve `y` hakkında faydalı bir anlama dikkat çeker: bir noktanın x ve y konumlarının kendileri estetiklerdir, verilerle ilgili bilgileri görüntülemek için değişkenlerle eşleştirebileceğiniz görsel özelliklerdir.

<!-- Once you map an aesthetic, ggplot2 takes care of the rest. It selects a reasonable scale to use with the aesthetic, and it constructs a legend that explains the mapping between levels and values. For x and y aesthetics, ggplot2 does not create a legend, but it creates an axis line with tick marks and a label. The axis line acts as a legend; it explains the mapping between locations and values. -->

Bir estetiği eşleştirdiğinizde, ggplot2 gerisini halleder. Estetikle kullanmak için makul bir ölçek seçer ve kademeler ve değerler arasındaki eşlemeyi açıklayan bir gösterge oluşturur. x ve y estetikleri için, ggplot2 bir gösterge oluşturmaz, ancak ölçüm çentikli ve etiketli bir eksen çizgisi oluşturur. Eksen çizgisi bir gösterge olarak hareket eder; konumlar ve değerler arasındaki eşlemeyi açıklar.

<!-- You can also _set_ the aesthetic properties of your geom manually. For example, we can make all of the points in our plot blue: -->

Ayrıca geom estetik özelliklerini manuel olarak da _ayarlayabilirsiniz_. Örneğin, grafiğimizdeki tüm noktaları mavi yapabiliriz:

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

<!-- Here, the color doesn't convey information about a variable, but only changes the appearance of the plot. To set an aesthetic manually, set the aesthetic by name as an argument of your geom function; i.e. it goes _outside_ of `aes()`. You'll need to pick a level that makes sense for that aesthetic: -->

Burada, renk değişken hakkında bilgi iletmez, yalnızca grafiğin görünümünü değiştirir. Bir estetiği manuel olarak ayarlamak için, estetiği adına göre geom fonksiyonunun bir argümanı olarak ayarlayın; yani `aes()`'in  _dışında_ olmalı. Bu estetik için mantıklı bir kademe seçmeniz gerekir:

<!-- * The name of a color as a character string. -->

* Bir rengin karakter dizisi olarak adı.

<!-- * The size of a point in mm. -->

* Bir noktanın mm cinsinden boyutu.

<!-- * The shape of a point as a number, as shown in Figure \@ref(fig:shapes). -->  

* Bir noktanın, Şekil \@ref(fig:shapes) 'de gösterildiği gibi sayı şeklinde biçimi.

```{r shapes, echo = FALSE, out.width = "75%", fig.asp = 1/3, fig.cap="R has 25 built in shapes that are identified by numbers. There are some seeming duplicates: for example, 0, 15, and 22 are all squares. The difference comes from the interaction of the `colour` and `fill` aesthetics. The hollow shapes (0--14) have a border determined by `colour`; the solid shapes (15--18) are filled with `colour`; the filled shapes (21--24) have a border of `colour` and are filled with `fill`.", warning = FALSE}
shapes <- tibble(
  shape = c(0, 1, 2, 5, 3, 4, 6:19, 22, 21, 24, 23, 20),
  x = (0:24 %/% 5) / 2,
  y = (-(0:24 %% 5)) / 4
)
ggplot(shapes, aes(x, y)) + 
  geom_point(aes(shape = shape), size = 5, fill = "red") +
  geom_text(aes(label = shape), hjust = 0, nudge_x = 0.15) +
  scale_shape_identity() +
  expand_limits(x = 4.1) +
  scale_x_continuous(NULL, breaks = NULL) + 
  scale_y_continuous(NULL, breaks = NULL, limits = c(-1.2, 0.2)) + 
  theme_minimal() +
  theme(aspect.ratio = 1/2.75)
```

<!-- ### Exercises -->  

### Alıştırmalar

<!-- 1.  What's gone wrong with this code? Why are the points not blue? -->  

1. Bu kodda yanlış olan nedir? Noktalar neden mavi değil?

    ```{r}
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))
    ```
    
<!-- 2.  Which variables in `mpg` are categorical? Which variables are continuous? 
    (Hint: type `?mpg` to read the documentation for the dataset). How
    can you see this information when you run `mpg`? -->  

2. `mpg`'deki hangi değişkenler kategoriktir? Hangileri devamlıdır? (İpucu: veri setinin dökümentasyonunu okumak için `?mpg` yazın.) Bu bilgiyi `mpg`'yi çalıştırdığınızda nasul görebilirsiniz?

<!-- 3.  Map a continuous variable to `color`, `size`, and `shape`. How do
    these aesthetics behave differently for categorical vs. continuous
    variables?  -->  

3. Bir devamlı değişkeni `renk` (`color`), `boyut` (`size`) ve `biçim` (`shape`) ile eşleyin. Bu estetikler devamlı ve kategorik değişkenlere göre nasıl değişiyorlar?
    
<!-- 4.  What happens if you map the same variable to multiple aesthetics?  -->  

4. Aynı değişkeni, birden fazla estetikle eşlerseniz ne olur?

<!-- 5.  What does the `stroke` aesthetic do? What shapes does it work with?
    (Hint: use `?geom_point`) -->  
    
5. `stroke` estetiği ne işe yarar? Hangi biçimlerle beraber çalışır? (İpucu: `?geom_point` kullanın.)
    
<!-- 6.  What happens if you map an aesthetic to something other than a variable 
    name, like `aes(colour = displ < 5)`?  Note, you'll also need to specify x and y. -->
    
6. Eğer bir estetiği `aes(colour = displ < 5)` gibi değişken adı dışında bir şeyler eşlerseniz ne olur? Dikkat, x ve y'yi de belirtmeniz gerekiyor.

<!-- ## Common problems -->  

## Sıkça rastlanan problemler

<!-- As you start to run R code, you're likely to run into problems. Don't worry --- it happens to everyone. I have been writing R code for years, and every day I still write code that doesn't work! -->  

R kodunu çalıştırmaya başladığınızda, sorunlarla karşılaşmanız olasıdır. Endişelenmeyin --- bu herkesin başına geliyor. Yıllardır R kodu yazıyorum ve her gün hala çalışmayan bir kod yazıyorum!

<!-- Start by carefully comparing the code that you're running to the code in the book. R is extremely picky, and a misplaced character can make all the difference. Make sure that every `(` is matched with a `)` and every `"` is paired with another `"`. Sometimes you'll run the code and nothing happens. Check the left-hand of your console: if it's a `+`, it means that R doesn't think you've typed a complete expression and it's waiting for you to finish it. In this case, it's usually easy to start from scratch again by pressing ESCAPE to abort processing the current command. -->  

Çalıştırdığınız kodu, kitaptaki kodla dikkatlice karşılaştırarak başlayın. R son derece seçicidir ve yanlış yerleştirilmiş bir karakter tüm farkı yaratabilir. Her `(` ile `)` ve her `"` bir başka `"` ile eşleştirilmiş olduğundan emin olun. Bazen kodu çalıştırırsınız ve hiçbir şey olmaz. Konsolunuzun sol tarafını kontrol edin: eğer bir `+` ise, R tam bir ifade yazdığınızı düşünmüyordur ve bitirmenizi bekler. Bu durumda, mevcut komutu işlemekten vazgeçmek için ESCAPE düğmesine basarak yeniden sıfırdan başlamak genellikle kolaydır.

<!-- One common problem when creating ggplot2 graphics is to put the `+` in the wrong place: it has to come at the end of the line, not the start. In other words, make sure you haven't accidentally written code like this: -->  

ggplot2 grafikleri oluştururken sık karşılaşılan bir sorun, `+` yı yanlış yere koymaktır: satırın başına değil, sonuna gelmelidir. Başka bir deyişle, yanlışlıkla aşağıdakı gibi bir kod yazmadığınızdan emin olun:

```R
ggplot(data = mpg) 
+ geom_point(mapping = aes(x = displ, y = hwy))
```

<!-- If you're still stuck, try the help. You can get help about any R function by running `?function_name` in the console, or selecting the function name and pressing F1 in RStudio. Don't worry if the help doesn't seem that helpful - instead skip down to the examples and look for code that matches what you're trying to do. -->  

Hala takılıyorsanız yardım sayfasını deneyin. Konsolda `?fonksiyon_adı` komutunu çalıştırarak veya fonksiyon adını seçip RStudio'da F1 tuşuna basarak herhangi bir R fonksiyonu hakkında yardım alabilirsiniz. Yardım bu kadar yardımcı görünmüyorsa endişelenmeyin - bunun yerine sayfa sonundaki örneklere atlayın ve yapmaya çalıştığınız kodla eşleşen kodu arayın.

<!-- If that doesn't help, carefully read the error message. Sometimes the answer will be buried there! But when you're new to R, the answer might be in the error message but you don't yet know how to understand it. Another great tool is Google: try googling the error message, as it's likely someone else has had the same problem, and has gotten help online. -->  

Bu işe yaramazsa, hata mesajını dikkatlice okuyun. Bazen cevap orada gömülü olacak! Fakat R'da yeniyseniz, cevap hata mesajında olabilir ancak henüz nasıl anlaşılacağını bilmiyorsunuzdur. Bir başka harika araç da Google: hata mesajını Google'da aratmayı deneyin, çünkü başka birinin de aynı sorunu yaşamış ve çevrimiçi yardım almış olması çok olası.

<!-- ## Facets -->  
## Facetler

<!-- One way to add additional variables is with aesthetics. Another way, particularly useful for categorical variables, is to split your plot into __facets__, subplots that each display one subset of the data. -->  

Estetikler ile ek değişkenler eklemenin bir yoludur. Özellikle ategorik değişkenler için yararlı olan bir başka yol, grafiğinizi her biri bir veri alt kümesini gösteren __facets__ 'e bölmektir.

<!-- To facet your plot by a single variable, use `facet_wrap()`. The first argument of `facet_wrap()` should be a formula, which you create with `~` followed by a variable name (here "formula" is the name of a data structure in R, not a synonym for "equation"). The variable that you pass to `facet_wrap()` should be discrete. -->  

Grafiğinizi tek bir değişken ile facetlemek için `facet_wrap()` kullanın. `facet_wrap()`'in ilk argümanı `~` ile yarattığınız ve ardından bir değişken adıyla oluşturduğunuz bir formül olmalıdır (burada "formül", "denklem" ile eş anlamlı değil, R'deki bir veri yapısının adıdır). `facet_wrap()` öğesine ilettiğiniz değişken ayrık olmalıdır.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

<!-- To facet your plot on the combination of two variables, add `facet_grid()` to your plot call. The first argument of `facet_grid()` is also a formula. This time the formula should contain two variable names separated by a `~`.  -->  

Grafiğinizi iki değişkenin birleşimi ile karşılaştırmak için, grafik komutunuza `facet_grid()` ekleyin. `facet_grid()`'in ilk argümanı da bir formüldür. Bu sefer formülde `~` ile ayrılan iki değişken ismi bulunmalıdır.

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```

<!-- If you prefer to not facet in the rows or columns dimension, use a `.` instead of a variable name, e.g. `+ facet_grid(. ~ cyl)`. -->  

Satırlar veya sütunlara göre facetlemeyi tercih etmezseniz, değişken adı yerine bir `.` kullanın; örneğin,`+ facet_grid(. ~ cyl)`.

<!-- ### Exercises -->  

### Alıştırmalar

<!-- 1.  What happens if you facet on a continuous variable? -->  

1. Devamlı bir değişkeni facetlerseniz ne olur?

<!-- 2.  What do the empty cells in plot with `facet_grid(drv ~ cyl)` mean?
    How do they relate to this plot? -->  
    
2. `facet_grid(drv ~ cyl)` ile grafiklediğinizde, grafikte görünen boş hüçcreler ne anlama gelir? Bu grafik ile nasıl ilişkilendirilebilirler?
    
    ```{r, eval = FALSE}
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = drv, y = cyl))
    ```

<!-- 3.  What plots does the following code make? What does `.` do? -->  

3. Aşağıdaki kod nasıl grafikler yapar? `.` ne işe yarar?

    ```{r eval = FALSE}
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) +
      facet_grid(drv ~ .)
    
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) +
      facet_grid(. ~ cyl)
    ```

<!-- 4.  Take the first faceted plot in this section: --> 

4. Bu bölmedeki ilk facetlenmiş grafiği alın:

    ```{r, eval = FALSE}
    ggplot(data = mpg) + 
      geom_point(mapping = aes(x = displ, y = hwy)) + 
      facet_wrap(~ class, nrow = 2)
    ```
    
<!-- What are the advantages to using faceting instead of the colour aesthetic?
    What are the disadvantages? How might the balance change if you had a 
    larger dataset? -->  
    
  Renk estetiği yerine facetleme kullanmanın avantajları nelerdir? Dezavantajları nelerdir? Daha büyük veri setininz olsaydı bu denge nasıl değişebilirdi?
    
<!-- 5.  Read `?facet_wrap`. What does `nrow` do? What does `ncol` do? What other
    options control the layout of the individual panels? Why doesn't
    `facet_grid()` have `nrow` and `ncol` arguments? -->  
    
5. `?facet_wrap` sayfasını okuyun. `nrow` ne işe yarar? `ncol` ne işe yarar? Tekil panellerin düzenini kontrol eden başka hangi seçenekler var? `facet_grid()`'in neden `nrow` ve `ncol` argümanları yok?

<!-- 6.  When using `facet_grid()` you should usually put the variable with more
    unique levels in the columns. Why? -->  
    
6. `facet_grid()` kullanırken, genellikle daha falza özgün kademesi olan değişkeni sütunlara koymalısınız. Neden?

<!-- ## Geometric objects -->  

## Geometrik cisimler

<!-- How are these two plots similar? -->

Bu iki grafik nasıl benzer olabilir?

```{r echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

<!-- Both plots contain the same x variable, the same y variable, and both describe the same data. But the plots are not identical. Each plot uses a different visual object to represent the data. In ggplot2 syntax, we say that they use different __geoms__. -->

İki grafik de aynı x ve y değişkenlerine sahip, her ikisi de aynı veriyi tanımlıyor. Ama grafikler birebir aynı değil. Her grafik, veriyi temsil eden farklı bir görsel cisim  kullanıyor. ggplot2 sözdizimine göre farklı __geomlar__ kullanıyorlar deriz.

<!-- A __geom__ is the geometrical object that a plot uses to represent data. People often describe plots by the type of geom that the plot uses. For example, bar charts use bar geoms, line charts use line geoms, boxplots use boxplot geoms, and so on. Scatterplots break the trend; they use the point geom. As we see above, you can use different geoms to plot the same data. The plot on the left uses the point geom, and the plot on the right uses the smooth geom, a smooth line fitted to the data.  -->

Bir __geom__, bir grafiğin veriyi temsil etmesi için kullandığı geometrik cisimdir. İnsanlar genelde grafiklerini kullanılan geoma göre tarif ederler. Örneğin, sütun grafikleri için sütun geomları, çizgi grafikleri için çizgi geomları, kutu grafikleri için kutu geomları vs. kullanılır. Dağılım grafikleri burada istisnadır; nokta geomunu kullanırlar. Yukarıda gördüğümüz gibi, aynı veriyi farklı geomlar kullanarak grafikleyebilirsiniz. Soldaki grafik nokta geomunu, sağdaki grafik verinin uyduğu düz bir çizgi oluşturan düz geomunu kullanır.

<!-- To change the geom in your plot, change the geom function that you add to `ggplot()`. For instance, to make the plots above, you can use this code: -->

Grafiğinizdeki geomu değiştirmek için, `ggplot()`'a eklediğiniz geom fonksiyonunu değiştirin. Mesela, yukarıdaki gibi grafikler yapmak için bu kodu kullanabilirsiniz:

```{r eval = FALSE}
# left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

# right
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

<!-- Every geom function in ggplot2 takes a `mapping` argument. However, not every aesthetic works with every geom. You could set the shape of a point, but you couldn't set the "shape" of a line. On the other hand, you _could_ set the linetype of a line. `geom_smooth()` will draw a different line, with a different linetype, for each unique value of the variable that you map to linetype. -->

ggplot2'deki her geom fonksiyonu bir `eşleme` argümanı alır. Ancak, her estetik her geom ile çalışmaz. Bir noktanın biçimini ayarlayabilirsizin, ama bir çizginin biçimini ayarlayamazsınız. Öte yandan, bir çizginin çizgi türünü _ayarlayabilirsiniz_. `geom_smooth()` çizgi türü ile eşlediğiniz değişkenin her özgün değeri için, farklı bir çizgi türü ile farklı bir çizgi çizecektir.

```{r message = FALSE}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))
```

<!-- Here `geom_smooth()` separates the cars into three lines based on their `drv` value, which describes a car's drivetrain. One line describes all of the points with a `4` value, one line describes all of the points with an `f` value, and one line describes all of the points with an `r` value. Here, `4` stands for four-wheel drive, `f` for front-wheel drive, and `r` for rear-wheel drive. -->

`geom_smooth()` burada arabaları, güç aktarımlarını anlatan `drv` değerlerine göre üç çizgiye ayırır. Bir çizgi `4` değerine sahip tüm noktaları, bir çizgi `f` değerine sahip tüm noktaları ve diğer bir çizgi de `r` değerine sahip tüm noktaları tanımlar. `4` burada dört çekerli, `f` önden çekerli ve `r` arkadan çekerli arabaları tasvir eder.

<!-- If this sounds strange, we can make it more clear by overlaying the lines on top of the raw data and then coloring everything according to `drv`.  -->

Eğer bu size garip geliyorsa, çizgileri ham veri ile üst üste koyup, `drv` değerine göre renklendirdiğimizde daha açıklayıcı hale getirebiliriz.

```{r echo = FALSE, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() +
  geom_smooth(mapping = aes(linetype = drv))
```

<!-- Notice that this plot contains two geoms in the same graph! If this makes you excited, buckle up. We will learn how to place multiple geoms in the same plot very soon.  -->

Bu grafiğin, aynı anda iki farklı geom içerdiğine dikkat edin! Eğer bu sizi heyecanlandırıyorsa, kemerlerinizi bağlayın. Çok yakında aynı grafiğe birden fazla geomu nasıl yerleştireceğimizi öğreneceğiz.

<!-- ggplot2 provides over 30 geoms, and extension packages provide even more (see <https://www.ggplot2-exts.org> for a sampling). The best way to get a comprehensive overview is the ggplot2 cheatsheet, which you can find at <http://rstudio.com/cheatsheets>. To learn more about any single geom, use help: `?geom_smooth`.  -->

ggplot2 30'dan fazla geom temin eder, hatta ek paketleriyle daha da fazla (örnekler için bkz. <https://www.ggplot2-exts.org>). Kapsamlı şekilde göz atmak için ggplot2 ipucu kağıtlarına bakın, <http://rstudio.com/cheatsheets> adresinden ulaşabilirsiniz. Bir geom hakkında daha fazla bilgiye ulaşmak için yardım sayfalarını kullanın: `?geom_smooth`.

<!-- Many geoms, like `geom_smooth()`, use a single geometric object to display multiple rows of data. For these geoms, you can set the `group` aesthetic to a categorical variable to draw multiple objects. ggplot2 will draw a separate object for each unique value of the grouping variable. In practice, ggplot2 will automatically group the data for these geoms whenever you map an aesthetic to a discrete variable (as in the `linetype` example). It is convenient to rely on this feature because the group aesthetic by itself does not add a legend or distinguishing features to the geoms.  -->

`geom_smooth()` gibi birçok geom, birden fazla veri satırını görüntülemek için bir adet geometrik cisim kullanır. Bu geomlar için, bir kategorik değişkene, birden fazla cismi çizmesi için `grup` estetiği belirleyebilirsiniz. Uygulamada, ne zaman bir estetiği bir ayrık değişken ile eşlerseniz (`çizgi türü` örneğinde olduğu gibi) ggplot2 otomatik olarak veriyi bu geomlara göre gruplayacaktır. Bu özelliğe güvenmek gayet elverişlidir; çünkü grup estetiği kendi başına bir gösterge ya da geomlşarı ayırt edici özellikler eklemez.

```{r, fig.width = 3, fig.align = 'default', out.width = "33%", message = FALSE}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
              
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
    
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE
  )
```

<!-- To display multiple geoms in the same plot, add multiple geom functions to `ggplot()`: -->

Birden fazla geomu aynı grafik üzerinde göstermek için `ggplot()`'a birden fazla geom fonksiyonu ekleyin:

```{r, message = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

<!-- This, however, introduces some duplication in our code. Imagine if you wanted to change the y-axis to display `cty` instead of `hwy`. You'd need to change the variable in two places, and you might forget to update one. You can avoid this type of repetition by passing a set of mappings to `ggplot()`. ggplot2 will treat these mappings as global mappings that apply to each geom in the graph.  In other words, this code will produce the same plot as the previous code: -->

Ancak bu kodumuzda tekrarlamaya sebep olur. y eksenini `hwy` yerine `cty` değerini gösterecek şekilde değiştirmek istediğinizi düşünün. Bu değişkeni iki yerde değiştirmeniz gerekir ve bir tanesini güncellemeyi unutabikirsiniz. Bu tarz tekrarları `ggplot()`'a bir eşleme seti atayarak önleyebilirsiniz. ggplot2 bu eşlemelere, grafikteki her geoma uygulacak şekilde, global eşlemeler gibi davranacaktır. Başka bir deyişle, bu kod, bir önceki kod ile aynı grafiği üretecektir:

```{r, eval = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```

<!-- If you place mappings in a geom function, ggplot2 will treat them as local mappings for the layer. It will use these mappings to extend or overwrite the global mappings _for that layer only_. This makes it possible to display different aesthetics in different layers. -->

Eşlemeleri bir geom fonksiyonunun içine koyarsanız, ggplot2 buna, o katmanın yerel eşlemesi olarak davranacaktır. Bu eşlemeleri _sadece o katman için_, global eşlemelerini genişletmek ya da üzerine yazmak için kullanacaktır. Böylece farklı katmanlarda farklı estetik gösterimleri yapabilirsiniz.

```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

<!-- You can use the same idea to specify different `data` for each layer. Here, our smooth line displays just a subset of the `mpg` dataset, the subcompact cars. The local data argument in `geom_smooth()` overrides the global data argument in `ggplot()` for that layer only. -->

Aynı yöntemi, her katmanda farklı `veri`leri belirtmek için de kullanabilirsiniz. Burada, düz çizgimiz sadece `mpg` veri setinin bir alt kümesi olan yarı-kompakt arabaları gösteriyor. Sadece bu katman için, `geom_smooth()`'taki yerel veri argümanı, `ggplot()`'un global veri argümanının geçersiz kılıyor.

```{r, message = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
```

<!-- (You'll learn how `filter()` works in the chapter on data transformations: for now, just know that this command selects only the subcompact cars.) -->

(Veri dönüşümleri üzerine olan bölümde `filter()` fonksiyonunun nasul çalıştığını öğreneceksiniz: Şimdilik sadece bu komutun yarı-kompakt arabaları seçtiğini bilin.)

<!-- ### Exercises -->

### Alıştırmalar

<!-- 1.  What geom would you use to draw a line chart? A boxplot? 
    A histogram? An area chart? -->
    
1. Çizgi grafiği çizmek için hangi geom kullanılır? Kutu grafiği için? Histogram? Alan grafiği?

<!-- 2.  Run this code in your head and predict what the output will look like.
    Then, run the code in R and check your predictions. -->
    
2. Kafanızda bu kodu çalıştırın ve çıktısının nasıl görüneceğini tahmin etmeye çalışın. Sonra, kodu R'da çalıştırın ve tahmininizi kontrol edin.
    
    ```{r, eval = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ```

<!-- 3.  What does `show.legend = FALSE` do?  What happens if you remove it?  
    Why do you think I used it earlier in the chapter? -->
    
3. `show.legend = FALSE` ne işe yarar? Kaldırınca ne olur? Size neden daha önce bu bölümde bunu kullandım?

<!-- 4.  What does the `se` argument to `geom_smooth()` do? -->

4. `se` argümanı `geom_smooth()` fonksiyonuna ne yaptırır?

<!-- 5.  Will these two graphs look different? Why/why not? -->

5. Bu iki grafik farklı görünecek mi? Neden?

    ```{r, eval = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point() + 
      geom_smooth()
    
    ggplot() + 
      geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
    ```

<!-- 6.  Recreate the R code necessary to generate the following graphs. -->

6. Aşağıdaki grafiği oluşturacak olan gerekli R kodunu yazın.
    
    ```{r echo = FALSE, fig.width = 3, out.width = "50%", fig.align = "default", message = FALSE}
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_smooth(aes(group = drv), se = FALSE) +
      geom_point()
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point(aes(color = drv)) + 
      geom_smooth(se = FALSE)
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point(aes(color = drv)) +
      geom_smooth(aes(linetype = drv), se = FALSE)
    ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
      geom_point(size = 4, colour = "white") + 
      geom_point(aes(colour = drv))
    ```

<!-- ## Statistical transformations -->

## İstatistiksel dönüşümler

<!-- Next, let's take a look at a bar chart. Bar charts seem simple, but they are interesting because they reveal something subtle about plots. Consider a basic bar chart, as drawn with `geom_bar()`. The following chart displays the total number of diamonds in the `diamonds` dataset, grouped by `cut`. The `diamonds` dataset comes in ggplot2 and contains information about ~54,000 diamonds, including the `price`, `carat`, `color`, `clarity`, and `cut` of each diamond. The chart shows that more diamonds are available with high quality cuts than with low quality cuts.  -->

Şimdi bir sütun grafiğine bakalım. Sütun gragikleri kolay görünebilir, ama aslında ilginçlerdir; çünkü grafikler hakkında göze çarpmayan şeyleri ortaya çıkarırlar. `geom_bar()` ile çizilmiş, basit bir sütun grafiği ele alalım. Aşağıdaki grafik `diamonds` veri seti içinde, `cut` değişkenine göre gruplandırılmış olarak toplam elmas sayısını gösteriyor. `diamonds` veri seti ggplot2 ile beraber gelir ve ~54,000 elmas hakkında `fiyat` (`price`), `renk` (`color`), `clarity` (`berraklık`) ve `kesim` (`cut`) değişkenleri hakkında bilgi içerir. Grafiğe göre yüksek kalite kesimli elmasların sayısı, düşük kalite kesimli elmasların sayısından fazladır.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

<!-- On the x-axis, the chart displays `cut`, a variable from `diamonds`. On the y-axis, it displays count, but count is not a variable in `diamonds`! Where does count come from? Many graphs, like scatterplots, plot the raw values of your dataset. Other graphs, like bar charts, calculate new values to plot: -->

x ekseninde, grafik `diamonds` veri setinden `cut` değişkenini gösterir. y ekseninde ise sayıyı gösterir, ancak sayı `diamonds` veri setinin içinde bir değişken değil! Sayı nereden geldi? Dağılım grafiği gibi birçok grafik, veri setinizin ham değerlerini gösterir. Diğer grafikler, sütun grafikleri gibi, yeni değerleri grafik için hesaplar:

<!-- * bar charts, histograms, and frequency polygons bin your data 
  and then plot bin counts, the number of points that fall in each bin. -->
 
* sütun grafikleri, histogramlar ve sıklık poligonları verilerinizi bölüyor ve daha sonra, her bir kutuya düşen noktaların sayısı olan arsa sayımı sayılır.

<!-- * smoothers fit a model to your data and then plot predictions from the
  model. -->
  
* yumuşatıcılar (?) verilerinizı bir modele uydurur ve ardından modelden çıkan tahminleri grafikler.

<!-- * boxplots compute a robust summary of the distribution and then display a 
  specially formatted box. -->

* kutu grafikleri dağılımın sağlam bir özetini hesaplar ve ardından özel olarak biçimlendirilmiş bir kutu gösterir.

<!-- The algorithm used to calculate new values for a graph is called a __stat__, short for statistical transformation. The figure below describes how this process works with `geom_bar()`. -->

Bir grafik için yeni veriler hesaplamaya yarayan algoritmaya __stat_ denir, istatistiksel dönüşümün kısaltılmışıdır. Aşağıdaki figür bu işlemin `geom_bar()` ile nasıl yapıldıgını anlatıyor.

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/visualization-stat-bar.png")
```

<!-- You can learn which stat a geom uses by inspecting the default value for the `stat` argument. For example, `?geom_bar` shows that the default value for `stat` is "count", which means that `geom_bar()` uses `stat_count()`. `stat_count()` is documented on the same page as `geom_bar()`, and if you scroll down you can find a section called "Computed variables". That describes how it computes two new variables: `count` and `prop`.-->

Bir geomun hangi stat değerini kullandığını, bu argümanın varsayılan haline bakarak görebilirsiniz. Örneğin, `?geom_bar`'ın varsayılan `stat` değeri "sayıdır" ("count"), yani, `geom_bar()` `stat_count()`'u kullanır. `stat_count()` ile `geom_bar()` aynı sayfada anlatılmıştır, eğer aşağıya doğru giderseniz "Hesaplanmış değerler" isimli bölümğ bulabilirsiniz. Bu, iki yeni değişkenin, `count` ve `prop`, nasıl hesaplandığını anlatır.

<!--You can generally use geoms and stats interchangeably. For example, you can recreate the previous plot using `stat_count()` instead of `geom_bar()`:-->

Genel olarak geom ve stat argümanlarınıı değişimli kullanabilirsiniz. Meselan, önceki grafiği tekrardan `geom_bar()` yerine `stat_count()` kullanarak oluşturabilirsiniz.

```{r}
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))
```

<!-- This works because every geom has a default stat; and every stat has a default geom. This means that you can typically use geoms without worrying about the underlying statistical transformation. There are three reasons you might need to use a stat explicitly: -->

Her geomun varsayılan bir stat argümanı olmasından ötürü bu gayet iyi çalışır; aynı zamanda her stat argümanının da bir geomu vardır. Bunun anlamı, geomları altındaki istatistiksel dönüşümü dert etmeksinizin kullanabilirsiniz. Özellikle stat kullanmanızı gerektirebilecek üç neden vardır:

<!-- 1.  You might want to override the default stat. In the code below, I change 
    the stat of `geom_bar()` from count (the default) to identity. This lets 
    me map the height of the bars to the raw values of a $y$ variable. 
    Unfortunately when people talk about bar charts casually, they might be
    referring to this type of bar chart, where the height of the bar is already
    present in the data, or the previous bar chart where the height of the bar
    is generated by counting rows. -->
    
1. Varsayılan stat argümanını geçersiz kılmak isteyebilirsiniz. Aşağıdaki kodda `geom_bar()`'ın stat argümanını sayıdan (varsayılan) birime çevirdim. Bu benim sütun boylarını ham $y$ değişkenine göre eşlememe izin verdi. Maalesef, insanlar arada sütun grafiklerinden bahsettiklerinde, sütun uzunluğu hali hazırda verinin içinde bulunan ya da önceki sütun grafiği gibi sütun uzunluğunun satır sayısı ile oluşturulduğu grafikleri kast ediyor olabilirler. 
    
    ```{r, warning = FALSE}
    demo <- tribble(
      ~cut,         ~freq,
      "Fair",       1610,
      "Good",       4906,
      "Very Good",  12082,
      "Premium",    13791,
      "Ideal",      21551
    )
    
    ggplot(data = demo) +
      geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")
    ```
    
<!--    (Don't worry that you haven't seen `<-` or `tribble()` before. You might be
    able to guess at their meaning from the context, and you'll learn exactly
    what they do soon!) -->
    
(Daha önce `<-` ya da `tribble()` fonksiyonunu görmediğiniz için endişelenmeyin. İçerikten anlamlarını aşağı yukarı anlayabilirsiniz, tam olarak ne yaptıklarını da yakında öğreneceksiniz!)

<!-- 2.  You might want to override the default mapping from transformed variables
    to aesthetics. For example, you might want to display a bar chart of
    proportion, rather than count: -->
    
2. Varsayılan eşlemeyi dönüştürülmüş değişkenlerden estetiklere değiştirmek isteyebilirsiniz. Örneğin, sayı yerine oran gösteren bir sütun grafiği oluşturmak isteyebilirsiniz:
    
    ```{r}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
    ```

<!--  To find the variables computed by the stat, look for the help section
    titled "computed variables". -->

Stat ile hesaplanan değişkenleri bulmak için "hesaplanan değişkenler" başlıklı yardım bölümüne bakın.

<!-- 3. You might want to draw greater attention to the statistical transformation
    in your code. For example, you might use `stat_summary()`, which
    summarises the y values for each unique x value, to draw 
    attention to the summary that you're computing: -->
    
Kodunuzda istatistiksel dönüşüme daha fazla dikkat çekmek isteyebilirsiniz. Örneğin, `stat_summary ()` fonksiyonunu kullanabilirsiniz; her özgün x değerinin y değerlerini hesapladığınız özete dikkat çekmek için özetler.

    ```{r}
    ggplot(data = diamonds) + 
      stat_summary(
        mapping = aes(x = cut, y = depth),
        fun.ymin = min,
        fun.ymax = max,
        fun.y = median
      )
    ```
    
<!-- ggplot2 provides over 20 stats for you to use. Each stat is a function, so you can get help in the usual way, e.g. `?stat_bin`. To see a complete list of stats, try the ggplot2 cheatsheet. -->

ggplot2, kullanmanız için 20'den fazla stat sunar. Her stat bir fonksiyondur, bu yüzden her zamanki gibi yardım alabilirsiniz; ör. `?stat_bin`. Statların tam bir listesini görmek için ggplot2 ipucu kağıdını deneyin.

<!-- ### Exercises -->

### Alıştırmalar

<!-- 1.  What is the default geom associated with `stat_summary()`? How could
    you rewrite the previous plot to use that geom function instead of the 
    stat function? -->
    
1. `stat_summary()` ile ilişkilendirilmiş varsayılan geom nedir? Bir önceki grafiğin kodunu stat yerine geom fonksiyonu kullanarak nasıl yazabilirsiniz?

<!-- 2.  What does `geom_col()` do? How is it different to `geom_bar()`? -->

2. `geom_col()` fonksiyonu ne yapar? `geom_bar()` fonksiyonundan farkı nedir?

<!-- 3.  Most geoms and stats come in pairs that are almost always used in 
    concert. Read through the documentation and make a list of all the 
    pairs. What do they have in common? -->
    
3. Birçok geom ve statlar sıkça kullanılan çiftler olarak gelirler. Bunun hakkındaki dökümanı okuyup tüm çiftlerin bir listesini yapın. Ortak özellikleri nedir?

<!-- 4.  What variables does `stat_smooth()` compute? What parameters control
    its behaviour? -->
    
4. `stat_smooth()` fonksiyonu hangi değişkenleri hesaplar? Hangi parametreler bu fonksiyonu kontrol eder?

<!-- 5.  In our proportion bar chart, we need to set `group = 1`. Why? In other
    words what is the problem with these two graphs? -->
    
5. Oran sütun grafiğimizde `group = 1` ayarlamamız gerekiyor. Neden? Diğer bir deyişle, bu iki grafiğin sorunu nedir?
    
    ```{r, eval = FALSE}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, y = ..prop..))
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))
    ```
  

<!-- ## Position adjustments -->

## Konum ayarları

<!-- There's one more piece of magic associated with bar charts. You can colour a bar chart using either the `colour` aesthetic, or, more usefully, `fill`: -->

Sütun grafikleriyle ilgili sihirli bir durum daha var. 'Renk' estetiğini veya daha faydalı bir şekilde 'dolgu' seçeneğini kullanarak bir sütun grafiğini renklendirebilirsiniz:

```{r out.width = "50%", fig.align = "default"}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```

<!-- Note what happens if you map the fill aesthetic to another variable, like `clarity`: the bars are automatically stacked. Each colored rectangle represents a combination of `cut` and `clarity`. -->

Dolgu estetiğini 'netlik' gibi başka bir değişkene eşlerseniz ne olacağını unutmayın: sütunlar otomatik olarak istiflenir. Her renkli dikdörtgen “kesik” ve “berraklık” kombinasyonunu temsil eder.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```

<!-- The stacking is performed automatically by the __position adjustment__ specified by the `position` argument. If you don't want a stacked bar chart, you can use one of three other options: `"identity"`, `"dodge"` or `"fill"`. -->

İstifleme, `position` argümanı tarafından belirtilen __konum ayarı__ ile otomatik olarak gerçekleştirilir. İstifli bir sütun grafik istemiyorsanız, diğer üç seçenekten birini kullanabilirsiniz: `"identity"` (`birim`), `"dodge"` veya `"fill"` (`dolgu`).

<!--  * `position = "identity"` will place each object exactly where it falls in 
    the context of the graph. This is not very useful for bars, because it
    overlaps them. To see that overlapping we either need to make the bars
    slightly transparent by setting `alpha` to a small value, or completely
    transparent by setting `fill = NA`. -->
    
* `position = "identity"` her nesneyi tam olarak grafik içinde nereye denk geliyorsa oraya yerleştirir. Bu, sütunlar için çok kullanışlı değildir, çünkü üst üste binmelerine sebep olur. Üst üste binenleri görmek için ya sütunları `alpha` değerini küçük tutarak kısmen saydam yapmamız ya da `fill = NA` ayarını yaparak tamamen saydam yapmamız gerekir.
    
    ```{r out.width = "50%", fig.align = "default"}
    ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
      geom_bar(alpha = 1/5, position = "identity")
    ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
      geom_bar(fill = NA, position = "identity")
    ```
    
<!--  The identity position adjustment is more useful for 2d geoms, like points,
    where it is the default. -->
    
Birim konum ayarı genellikle, nokta gibi 2 boyutlu geomların varsayılanıdır, onlar için daha kullanışlıdır.
    
<!--  * `position = "fill"` works like stacking, but makes each set of stacked bars
    the same height. This makes it easier to compare proportions across 
    groups. -->
    
`position ="fill"` istifleme gibi çalışır, ancak her istiflenmiş sütun setini aynı boyda oluşturur. Bu, gruplar arasındaki oranların karşılaştırılmasını kolaylaştırır.

    ```{r}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
    ```

<!--  *  `position = "dodge"` places overlapping objects directly _beside_ one 
    another. This makes it easier to compare individual values. -->
    
* `position ="dodge"` çakışan nesneleri doğrudan _yan yana_ yerleştirir. Bu, bireysel değerleri karşılaştırmayı kolaylaştırır.

    ```{r}
    ggplot(data = diamonds) + 
      geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
    ```

<!--  There's one other type of adjustment that's not useful for bar charts, but it can be very useful for scatterplots. Recall our first scatterplot. Did you notice that the plot displays only 126 points, even though there are 234 observations in the dataset? -->

Sütun grafikler için pek kullanışlı olmayan başka bir ayarlama daha var, ancak dağılım grafikleri için çok yararlı olabilir. İlk dağılım grafiğimizi hatırlayın. Veri setinde 234 gözlem olmasına rağmen, grafiğin sadece 126 puan gösterdiğini fark ettiniz mi?

```{r echo = FALSE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

<!--  The values of `hwy` and `displ` are rounded so the points appear on a grid and many points overlap each other. This problem is known as __overplotting__. This arrangement makes it hard to see where the mass of the data is. Are the data points spread equally throughout the graph, or is there one special combination of `hwy` and `displ` that contains 109 values?  -->

`hwy` ve `displ` değerleri yuvarlanır, böylece noktalar bir ağ üzerinde görünür ve birçok nokta birbiriyle örtüşür. Bu sorun __overplotting__ olarak bilinir. Bu düzenleme, veri kütlesinin nerede yoğunlaştığını görmeyi zorlaştırmaktadır. Veri noktaları grafik boyunca eşit bir şekilde yayılmış mı, yoksa 109 değer içeren özel bir`hwy` ve `displ` kombinasyonu mu var?

<!--  You can avoid this gridding by setting the position adjustment to "jitter". `position = "jitter"` adds a small amount of random noise to each point. This spreads the points out because no two points are likely to receive the same amount of random noise. -->

Konum ayarını "seğirmeye" ayarlayarak bu ağlardan kaçınabilirsiniz. `position = "jitter"` her noktaya az miktarda rastgele gürültü ekler. Bu, noktaları yaymaktadır çünkü iki noktanın rastgele aynı gürültü değerini alması muhtemel değildir.


```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

<!--  Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph _more_ revealing at large scales. Because this is such a useful operation, ggplot2 comes with a shorthand for `geom_point(position = "jitter")`: `geom_jitter()`. -->

Rastgelelik eklemek, grafiğinizi geliştirmek için garip bir yol gibi görünebilir, ancak grafiğinizi küçük ölçeklerde daha az doğru hale getirmesine rağmen grafiğinizi büyük ölçeklerde _daha çok_ ortaya çıkarır. Bu çok faydalı bir işlem olduğundan, ggplot2 `geom_point(position = "jitter")` için bir kısa yola sahiptir: `geom_jitter()`.

<!--  To learn more about a position adjustment, look up the help page associated with each adjustment: `?position_dodge`, `?position_fill`, `?position_identity`, `?position_jitter`, and `?position_stack`. -->

Bir pozisyon ayarlaması hakkında daha fazla bilgi edinmek için, her bir ayarlamayla ilgili yardım sayfasına bakın: `?position_dodge`, `?position_fill`, `?position_identity`, `?position_jitter` ve `?position_stack`.

<!--  ### Exercises -->

### Alıştırmalar

<!--  1.  What is the problem with this plot? How could you improve it? -->

1. Bu grafikteki problem nedir? Nasıl geliştirebilirsiniz?

    ```{r}
    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
      geom_point()
    ```

<!--  2.  What parameters to `geom_jitter()` control the amount of jittering? -->

2. `geom_jitter()`'daki seğirme ayarını hangi parametreler kontrol eder?

<!--  3.  Compare and contrast `geom_jitter()` with `geom_count()`. -->

`geom_jitter()` ile `geom_count()` fonksiyonlarınıı karşılaştırın.

<!--  4.  What's the default position adjustment for `geom_boxplot()`? Create
    a visualisation of the `mpg` dataset that demonstrates it. -->

`geom_boxplot()` için varsayılan konum ayarı nedir? `mpg` veri setini kullanara bunu gösteren bir görsel oluşturun.

<!--  ## Coordinate systems -->

## Koordinat sistemleri

<!--  Coordinate systems are probably the most complicated part of ggplot2. The default coordinate system is the Cartesian coordinate system where the x and y positions act independently to determine the location of each point. There are a number of other coordinate systems that are occasionally helpful. -->

Koordinat sistemleri muhtemelenm ggplot2'nin en karışık kısmıdır. Varsayılan koordinat sistemi Kartezyen koordinat sistemidir, x ve y konumları her bir noktanın yerini belirlemek için bağımsız hareket ederler. Arada yardımcı olabilecek bir takım başka koordinat sistemleri bulunur.

<!--  * `coord_flip()` switches the x and y axes. This is useful (for example),
    if you want horizontal boxplots. It's also useful for long labels: it's
    hard to get them to fit without overlapping on the x-axis. -->
    
* `coord_flip()` fonksiyonu, x ve y eksenlerinin yerlerini değiştirir. Bu yararlıdır (örneğin), eğer yatay kutu grafikleri istiyorsanız. ynı zamanda uzun etiketler için de yararlıdır: x ekseninde etikletleri üst üste binmeden sığdırmak zor. ->

    
    ```{r fig.width = 3, out.width = "50%", fig.align = "default"}
    ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
      geom_boxplot()
    ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
      geom_boxplot() +
      coord_flip()
    ```

<!--  * `coord_quickmap()` sets the aspect ratio correctly for maps. This is very
    important if you're plotting spatial data with ggplot2 (which unfortunately
    we don't have the space to cover in this book). -->
    
* `coord_quickmap()`, haritalar için en boy oranını doğru ayarlar. Eğer mekansal verileri ggplot2 ile çiziyorsanız bu çok önemlidir (maalesef bu kitapta kapsayacak yerimiz yok).

    ```{r fig.width = 3, out.width = "50%", fig.align = "default", message = FALSE}
    nz <- map_data("nz")

    ggplot(nz, aes(long, lat, group = group)) +
      geom_polygon(fill = "white", colour = "black")

    ggplot(nz, aes(long, lat, group = group)) +
      geom_polygon(fill = "white", colour = "black") +
      coord_quickmap()
    ```

<!--  * `coord_polar()` uses polar coordinates. Polar coordinates reveal an 
    interesting connection between a bar chart and a Coxcomb chart. -->
    
* `coord_polar()` kutupsal koordinatları kullanır. Kutupsal koordinatları sütun grafikleri ile Coxcomb (Kutupsal Daire) grafikleri arasında ilginç bir bağlantı ortaya çıkarır.
    
    ```{r fig.width = 3, out.width = "50%", fig.align = "default", fig.asp = 1}
    bar <- ggplot(data = diamonds) + 
      geom_bar(
        mapping = aes(x = cut, fill = cut), 
        show.legend = FALSE,
        width = 1
      ) + 
      theme(aspect.ratio = 1) +
      labs(x = NULL, y = NULL)
    
    bar + coord_flip()
    bar + coord_polar()
    ```

<!--  ### Exercises -->

### Alıştırmalar

<!-- 1.  Turn a stacked bar chart into a pie chart using `coord_polar()`. -->

1. İstiflenmiş bir sütun grafiğini `coord_polar()` kullanarak bir pasta grafiğine çevirin.

<!-- 2.  What does `labs()` do? Read the documentation. -->

2. `labs()` fonksiyonu ne yapar. Dökümentasyonunu okuyun.

<!-- 3.  What's the difference between `coord_quickmap()` and `coord_map()`? -->

3. `coord_quickmap()` ve `coord_map()` arasındaki fark nedir?

<!-- 4.  What does the plot below tell you about the relationship between city
    and highway mpg? Why is `coord_fixed()` important? What does 
    `geom_abline()` do? -->
    
4. Aşağıdaki grafik mpg verisindeki şehir ve otoban ilişkisi hakkında ne anlatır? `coord_fixed()` neden önemlidir? `geom_abline()` ne işe yarar?
    
    ```{r, fig.asp = 1, out.width = "50%"}
    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
      geom_point() + 
      geom_abline() +
      coord_fixed()
    ```

<!-- ## The layered grammar of graphics -->

## Katmanlı grafik grameri

<!-- In the previous sections, you learned much more than how to make scatterplots, bar charts, and boxplots. You learned a foundation that you can use to make _any_ type of plot with ggplot2. To see this, let's add position adjustments, stats, coordinate systems, and faceting to our code template: -->

Önceki bölümlerde, dağılma grafiklerinden, sütun ve kutu grafiklerinin nasıl yapıldığından çok daha fazlasını öğrendiniz. ggplot2 ile _herhangi_ bir grafik yapmak için kullanabileceğiniz bir temel öğrendiniz. Bunu görmek için kod şablonumuza konum ayarlamaları, stat, koordinat sistemleri ve facet ekleyelim:

```
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>
```

<!-- Our new template takes seven parameters, the bracketed words that appear in the template. In practice, you rarely need to supply all seven parameters to make a graph because ggplot2 will provide useful defaults for everything except the data, the mappings, and the geom function. -->

Yeni şablonumuzda, parantez içindeki kelimelerle berlirtilen yedi parametre var. Uygulamada, bir grafik oluşturmak için nadiren yedi parametrenin tümünü sağlamanız gerekir, çünkü ggplot2 veri, eşlemeler ve geom fonksiyonu dışındaki her şey için yararlı varsayılan ayarları sağlar.

<!-- The seven parameters in the template compose the grammar of graphics, a formal system for building plots. The grammar of graphics is based on the insight that you can uniquely describe _any_ plot as a combination of a dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, and a faceting scheme.  -->

Şablondaki yedi parametre, grafikleri oluşturmak için resmi bir sistem olan grafiklerin gramerini oluşturur. Grafiklerin dilbilgisi, _herhangi_  bir grafiği bir veri kümesi, bir geom, bir dizi eşleme, bir stat, bir konum ayarlaması, bir koordinat sistemi ve bir facet şeması kombinasyonu olarak özgün bir şekilde tanımlayabileceğiniz anlayışına dayanmaktadır.

<!-- To see how this works, consider how you could build a basic plot from scratch: you could start with a dataset and then transform it into the information that you want to display (with a stat). -->

Bunun nasıl çalıştığını görmek için, sıfırdan basit bir grafiği nasıl yapabileceğinizi düşünün: bir veri setiyle başlayıp ardından onu (bir stat ile) görüntülemek istediğiniz bilgilere dönüştürebilirsiniz.

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/visualization-grammar-1.png")
```

<!-- Next, you could choose a geometric object to represent each observation in the transformed data. You could then use the aesthetic properties of the geoms to represent variables in the data. You would map the values of each variable to the levels of an aesthetic. -->

Daha sonra, dönüştürülen verilerdeki her bir gözlemi temsil etmek için geometrik bir cisim seçebilirsiniz. Sonra verilerdeki değişkenleri temsil etmek için geomların estetik özelliklerini kullanabilirsiniz. Her değişkenin değerlerini estetik kademelerle eşleştirebilirsiniz.

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/visualization-grammar-2.png")
```

<!-- You'd then select a coordinate system to place the geoms into. You'd use the location of the objects (which is itself an aesthetic property) to display the values of the x and y variables. At that point, you would have a complete graph, but you could further adjust the positions of the geoms within the coordinate system (a position adjustment) or split the graph into subplots (faceting). You could also extend the plot by adding one or more additional layers, where each additional layer uses a dataset, a geom, a set of mappings, a stat, and a position adjustment. -->

Daha sonra geomları yerleştirmek için bir koordinat sistemi seçersiniz. x ve y değişkenlerinin değerlerini görüntülemek için cisimlerin konumunu (kendisi estetik bir özelliktir) kullanırsınız. Bu noktada tam bir grafiğiniz olacaktır, ancak koordinat sistemi içindeki geomların konumlarını daha da ayarlayabilir (bir konum ayarı ile) ya da grafiği alt grafiklere (facet ile) bölebilirsiniz. Grafiği, her bir ek veri kümesinin, bir geom'geomun, bir dizi eşlemenin, bir statın ve bir konum ayarının kullanıldığı bir veya daha fazla ek katman ekleyerek de genişletebilirsiniz.

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("images/visualization-grammar-3.png")
```

<!-- You could use this method to build _any_ plot that you imagine. In other words, you can use the code template that you've learned in this chapter to build hundreds of thousands of unique plots. -->

Bu yöntemi, hayal ettiğiniz _herhangi_ bir grafiği oluşturmak için kullanabilirsiniz. Başka bir deyişle, bu bölümde öğrendiğiniz kod şablonunu, yüz binlerce benzersiz çizim oluşturmak için kullanabilirsiniz.
